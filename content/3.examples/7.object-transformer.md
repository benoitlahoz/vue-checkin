---
title: Object Transformer
description: Transform, manipulate, and apply recipes to JSON objects with real-time preview.
navigation:
  icon: i-lucide-git-branch
seo:
  title: Object Transformer - VueAirport
  description: Transform, manipulate, and apply recipes to JSON objects with real-time preview.
---

This example demonstrates a **component-based** JSON transformation system with visual tree editor, 40+ transforms, recipe export/import, and template mode for arrays. 

**Key Architecture**: All components register with a shared desk using VueAirport's `useCheckIn`. Child components access shared state directly through desk registration, enabling clean separation of concerns.

::example-loader{:component="ExampleTransformer"}
::

## Component-Based Architecture

This example showcases VueAirport's **component-based pattern** where:
- **No props are passed between components**
- Each component registers independently with the desk using `useCheckIn`
- Shared state (tree, transforms, mode) is accessed through desk context
- Components communicate through desk updates, not parent-child props

## Project Structure

```
object-transformer/
├── index.ts                           # Shared types and desk key
├── ExampleTransformer.vue             # Demo wrapper (creates desk)
├── ModeToggle.vue                     # Object/Model mode switch
├── NodeActions.vue                    # Transform/delete actions
├── NodeKeyEditor.vue                  # Inline key editing
├── NodeOpen.vue                       # Expand/collapse toggle
├── ObjectNode.vue                     # Recursive tree node
├── ObjectPreview.vue                  # JSON preview display
├── ObjectTransformer.vue              # Root container component
├── RecipePreview.vue                  # Recipe JSON preview
├── TransformParam.vue                 # Transform parameters editor
├── TransformSelect.vue                # Transform selector dropdown
├── transforms/                        # Transform category components
│   ├── TransformArray.vue             # Array transforms (Map, Filter, etc.)
│   ├── TransformBoolean.vue           # Boolean transforms
│   ├── TransformDate.vue              # Date transforms (Format, ISO, etc.)
│   ├── TransformNumber.vue            # Number transforms (Round, Abs, etc.)
│   ├── TransformObject.vue            # Object transforms (Merge, Flatten, etc.)
│   └── TransformString.vue            # String transforms (Split, Uppercase, etc.)
└── utils/
    ├── common-structural-handlers.util.ts    # Common structural transform handlers
    ├── functional.util.ts                    # Functional utilities (partition, etc.)
    ├── model-mode.util.ts                    # Model mode helpers
    ├── model-rules.util.ts                   # Model transformation rules
    ├── node-builder.util.ts                  # Tree node construction
    ├── node-editing.util.ts                  # Node editing operations
    ├── node-transforms.util.ts               # Node transform application
    ├── node-utilities.util.ts                # Node utility functions
    ├── structural-transform-handlers.util.ts # Structural transform handlers
    ├── transform-propagation.util.ts         # Structural transform propagation
    ├── transform-recipe.util.ts              # Recipe serialization/application
    └── type-guards.util.ts                   # Type guard utilities
```

## Root Component (ExampleTransformer.vue)

Creates the desk and provides initial data. **No props are passed to children** except an id - they all register independently:

```vue
<script setup lang="ts">
import {
  ObjectTransformer,
  ObjectPreview,
  RecipePreview,
  ObjectNode,
  ModeToggle,
  TransformString,
  TransformNumber,
  TransformDate,
  TransformBoolean,
  TransformObject,
  TransformArray,
} from '.';

// Array of user objects for model mode demonstration
const data = [
  {
    name: 'john doe',
    age: 30,
    dob: new Date('1993-05-15T00:00:00Z'),
    active: true,
    city: 'marseille',
    address: {
      street: '123 main st',
      zip: '13001',
      custom: {
        info: 'some custom info',
        tags: ['tag1', 'tag2'],
      },
    },
    hobbies: ['reading', 'traveling', 'swimming'],
  },
  {
    name: 'jane smith',
    age: 28,
    active: false,
    city: 'paris',
    address: {
      street: '456 elm st',
      zip: '75001',
    },
    hobbies: ['cooking', 'painting'],
  },
  {
    name: 'bob wilson',
    age: 35,
    dob: new Date('1988-03-20T00:00:00Z'),
    active: true,
    city: 'lyon',
    address: {
      street: '789 oak ave',
      zip: '69001',
      custom: {
        info: 'another info',
      },
    },
  },
];
</script>

<template>
  <div class="space-y-4 max-h-196 overflow-auto">
    <!-- ObjectTransformer creates the desk internally -->
    <ObjectTransformer :data="data" class="flex md:flex-row w-full">
      <!-- Transform category components - register independently -->
      <TransformString />
      <TransformNumber />
      <TransformDate />
      <TransformBoolean />
      <TransformObject />
      <TransformArray />

      <!-- Tree editor - registers independently -->
      <div class="flex-1 flex flex-col gap-2">
        <ModeToggle />
        <ObjectNode />
      </div>

      <!-- Preview panels - register independently -->
      <div class="flex-1 flex flex-col gap-2 h-full">
        <ObjectPreview />
        <RecipePreview />
      </div>
    </ObjectTransformer>
  </div>
</template>
```

**Notice**: No props drilling! Each component (`TransformString`, `ObjectNode`, `ObjectPreview`, etc.) accesses the desk independently through `useCheckIn`.

## Transform Components (transforms/TransformString.vue)

Transform components register transform definitions with the desk on mount. Each transform category is a Vue component:

```vue
<script setup lang="ts">
import { useCheckIn } from 'vue-airport';
import type { ObjectTransformerContext, Transform } from '..';
import { ObjectTransformerDeskKey, registerStructuralTransformHandler } from '..';

type DeskWithContext = typeof desk & ObjectTransformerContext;

// Register structural transform handler for 'split'
registerStructuralTransformHandler('split', (current, lastKey, result) => {
  if (!Array.isArray(result.parts)) return;

  // Create new properties from parts
  result.parts.forEach((part: any, index: number) => {
    const newKey = `${lastKey}_${index}`;
    current[newKey] = part;
  });

  // Remove source if specified
  if (result.removeSource) {
    delete current[lastKey];
  }
});

const transforms: Transform[] = [
  {
    name: 'Split',
    structural: true, // Structural transform creates new nodes
    if: (node) => node.type === 'string',
    params: [{ key: 'delimiter', label: 'Delimiter', type: 'text', default: ' ' }],
    fn: (v: string, delimiter: string) => {
      if (typeof v !== 'string') return v;
      return {
        __structuralChange: true,
        action: 'split' as const,
        parts: v.split(delimiter),
        removeSource: false,
      };
    },
  },
  {
    name: 'Uppercase',
    if: (node) => node.type === 'string',
    fn: (v: any) => (typeof v === 'string' ? v.toUpperCase() : v),
  },
  {
    name: 'Capitalized',
    if: (node) => node.type === 'string',
    fn: (v: any) =>
      typeof v === 'string' ? v.charAt(0).toUpperCase() + v.slice(1).toLowerCase() : v,
  },
  {
    name: 'To Object',
    structural: true,
    if: (node) => node.type === 'string',
    fn: (v: string) => {
      if (typeof v !== 'string') return v;
      return {
        __structuralChange: true,
        action: 'toObject' as const,
        object: { object: { value: v } },
        removeSource: false,
      };
    },
  },
  // ... 10+ more string transforms
];

// Register with desk on mount - no props needed!
const { checkIn } = useCheckIn<Transform, ObjectTransformerContext>();
const { desk } = checkIn(ObjectTransformerDeskKey, {
  id: 'string-transform',
  autoCheckIn: true,
});

onMounted(() => {
  const d = desk as DeskWithContext;
  d.addTransforms(...transforms); // Register transforms with shared desk
});
</script>

<template>
  <!-- No UI - just registers transforms on mount -->
  <div class="hidden"></div>
</template>
```

**Key Points**:
- Each transform component registers its transforms via `desk.addTransforms()`
- No props passed - component accesses desk independently
- Transforms are registered once on mount
- Other components (like `TransformSelect`) access these transforms from desk context
- Enables modular organization by data type (string, number, date, etc.)

## Desk-Based Component Registration

ObjectTransformer creates a desk with shared context:

```typescript
// ObjectTransformer.vue (simplified)
const { createDesk } = useCheckIn<ObjectNodeData, TransformerContext>();
const { desk } = createDesk(OBJECT_TRANSFORMER_DESK_KEY, {
  devTools: true,
  context: {
    tree: ref<ObjectNodeData[]>([]),
    originalData: ref(props.data),
    mode: ref<'object' | 'model'>('object'),
    transforms: ALL_TRANSFORMS,
    // ... other shared state
  },
});
```

Child components register **without any props**:

```typescript
// ObjectNode.vue, ObjectPreview.vue, TransformString.vue, etc.
const { checkIn } = useCheckIn<ObjectNodeData, TransformerContext>();
const { desk } = checkIn(OBJECT_TRANSFORMER_DESK_KEY, {
  autoCheckIn: false,
  watchData: false,
});

// Access shared state directly
const tree = computed(() => desk!.tree);
const mode = computed(() => desk!.mode.value);
const transforms = computed(() => desk!.transforms);
```

This pattern eliminates props drilling and enables flexible component composition.

## Key Concepts

### Three-Tier Key System

Each node maintains three distinct keys for robust rename tracking:

- **`firstKey`**: Immutable original key at creation (never changes)
- **`originalKey`**: Current expected key reflecting parent structural changes
- **`key`**: Actual display key (custom if manually renamed via `keyModified` flag)

This system ensures:
- Child renames persist when parent nodes are renamed or transformed
- Recipe paths remain accurate for structural transformations
- Undo/redo operations preserve user intentions

Example flow:
```typescript
// Initial state
{ firstKey: 'name', originalKey: 'name', key: 'name', keyModified: false }

// User renames to 'fullName'
{ firstKey: 'name', originalKey: 'name', key: 'fullName', keyModified: true }

// Parent applies 'Split' transform creating 'name_object'
// Child's originalKey updates, but user rename preserved
{ firstKey: 'name', originalKey: 'name_object', key: 'fullName', keyModified: true }
```

### Transform Types

Transforms are categorized by structural impact:

**Structural Transforms** (create/remove nodes):
- `To Object`, `Split`, `Array to Properties`
- Trigger node tree rebuilding
- Update `originalKey` for affected children
- Preserve user renames via `keyModified` flag

**Non-Structural Transforms** (modify values):
- `Capitalized`, `Uppercase`, `Lowercase`, `Trim`, `Number`, etc.
- Update node's `transform` property
- No tree restructuring needed

### Recipe System

Recipes are portable JSON documents describing transformations:

```typescript
interface TransformRecipe {
  steps: Array<{
    path: string[];           // Path to target node (for transforms/deletions)
    renamePath: string[];     // Path for renames (reflects current structure)
    transform?: string;       // Transform name
    params?: any;            // Transform parameters
  }>;
  deletions: string[][];     // Paths to deleted nodes
  renames: Array<{
    path: string[];          // Path to renamed node
    newKey: string;          // New key name
  }>;
}
```

**Recipe Generation** (`buildRecipe`):
- Traverses tree collecting transforms, deletions, renames
- Uses `originalPath` for data operations (transforms/deletions)
- Uses `renamePath` for rename operations (current structure)
- Skips numeric indices for array templates (template mode)

**Recipe Application** (`applyRecipe`):
- Detects array data with object recipe → applies to each element
- Sequential execution: transforms → deletions → sorted renames
- Renames sorted by path depth (parents before children)

### Mode Switching

**Object Mode**: Edit single object directly

**Model Mode**: 
- For arrays, uses first element as template
- Recipe applied to all array elements
- Enables batch transformations

### Node Tracking

Nodes created by structural transforms maintain identity:

- **`splitSourceId`**: ID of source node that created this node
- **`splitIndex`**: Position in split (0, 1, 2...)

This enables node reuse when structural transforms re-execute, preserving user customizations.

## How It Works

1. **Initial Tree Build**: `buildNodeTree` creates recursive structure from data
2. **User Interactions**:
   - Rename keys → Updates `key` and sets `keyModified: true`
   - Apply transform → Updates `transform` property, triggers propagation if structural
   - Delete node → Marks `isDeleted: true`
3. **Structural Transform Propagation**:
   - Identifies existing nodes by `splitSourceId` and `splitIndex`
   - Reuses nodes to preserve user customizations
   - Updates `originalKey` for children affected by parent changes
   - Preserves `key` if `keyModified: true`
4. **Recipe Export**:
   - Traverses tree with dual path tracking
   - Serializes transforms, deletions, renames
   - Downloads as JSON file
5. **Recipe Import**:
   - Applies recipe to `originalData`
   - Rebuilds tree from transformed result
   - Displays final output
6. **Preview Update**:
   - Computed property applies all transforms
   - Real-time JSON preview with syntax highlighting

## Recipe Workflow

### Exporting a Recipe

1. User applies transforms, renames, deletions to tree
2. Clicks "Export Recipe"
3. `buildRecipe` traverses tree:
   - Collects all transforms with `originalPath` (data reference)
   - Collects deletions with `originalPath`
   - Collects renames with `renamePath` (current structure)
4. JSON file downloads with complete transformation definition

### Importing a Recipe

1. User selects JSON recipe file
2. `applyRecipe` detects data type:
   - If array + object recipe → template mode (apply to all elements)
   - Otherwise → direct application
3. `applySingleRecipe` executes sequentially:
   - Apply transforms at specified paths
   - Delete nodes at specified paths
   - Rename nodes (sorted by depth)
4. Tree rebuilds from transformed result
5. Preview shows final output

### Template Mode for Arrays

When importing an object recipe to array data:

```typescript
// Recipe for single object
const recipe = {
  steps: [
    { path: ['name'], renamePath: ['name'], transform: 'Capitalized' }
  ],
  renames: [
    { path: ['name'], newKey: 'fullName' }
  ]
};

// Applied to array
const arrayData = [
  { name: 'alice' },
  { name: 'bob' }
];

// Result: recipe applied to each element
const result = [
  { fullName: 'Alice' },
  { fullName: 'Bob' }
];
```

## Available Transforms (40+)

**Case Transforms**: Capitalized, Uppercase, Lowercase, Title Case, Camel Case, Snake Case, Kebab Case

**Type Conversions**: Number, String, Boolean, Parse JSON, Stringify JSON

**String Manipulation**: Trim, Trim Start, Trim End, Reverse, Length, Truncate, Pad Start, Pad End

**Structural**: To Object, Split, Array to Properties, Flatten, Merge

**Numeric**: Absolute, Round, Floor, Ceil, Increment, Decrement

**Date/Time**: Format Date, ISO String, Timestamp

**Data Operations**: Remove Nulls, Remove Empty Strings, Deduplicate, Sort

## Usage

This pattern is ideal for:
- JSON data transformation pipelines
- API response reshaping
- Data migration with reproducible recipes
- Batch transformations on arrays
- Visual data mapping tools
- ETL (Extract, Transform, Load) workflows

## Why Component-Based with Desk Registration?

Traditional approach (props drilling):
```vue
<!-- ❌ Props drilling - brittle and verbose -->
<ObjectTransformer :data="data">
  <ObjectNode :tree="tree" :transforms="transforms" :mode="mode">
    <NodeActions :tree="tree" :transforms="transforms" />
    <NodeKeyEditor :node="node" :tree="tree" @update="handleUpdate" />
  </ObjectNode>
  <ObjectPreview :tree="tree" :original="data" />
</ObjectTransformer>
```

VueAirport approach (desk registration):
```vue
<!-- ✅ No props - components register independently -->
<ObjectTransformer :data="data">
  <ObjectNode />
  <ObjectPreview />
  <TransformString />
  <RecipePreview />
</ObjectTransformer>
```

**Benefits**:
- **No props drilling**: Components access shared state directly
- **Flexible composition**: Add/remove/reorder components freely
- **Clean separation**: Each component manages its own registration
- **Type safety**: Full TypeScript support through desk context
- **DevTools integration**: Automatic state tracking and debugging

The combination of visual editing, portable recipes, template mode, and **component-based architecture** makes it a powerful tool for complex data transformations.



