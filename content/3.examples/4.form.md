---
title: Form Validation
description: Form field validation with real-time feedback and error handling.
navigation:
  icon: i-heroicons-document-text
seo:
  title: Form Validation - VueAirport
  description: Build forms with powerful validation using VueAirport's validation plugin. Real-time feedback, custom validators, and error management.
---

A complete form validation example demonstrating the validation plugin:

- Custom validation plugin with field-level rules
- Real-time validation feedback
- Form submission with validation
- Error cache management
- Required field and email validation

::example-loader{:component="Form"}
::

## Project Structure

```
form/
├── index.ts           # Shared types and injection key
├── Form.vue           # Parent form component
└── FormField.vue      # Individual field component
```

## Shared Types (index.ts)

```typescript
import type { InjectionKey } from 'vue';
import type { DeskCore } from '#vue-airport/composables/useCheckIn';

export interface FieldData {
  label: string;
  value: string;
  type: 'text' | 'email' | 'number';
  required: boolean;
}

export const FORM_DESK_KEY: InjectionKey<DeskCore<FieldData>> = Symbol('formDesk');

export { default as Form } from './Form.vue';
export { default as FormField } from './FormField.vue';
```

## Parent Component (Form.vue)

Creates a desk with validation plugin:

```vue
<script setup lang="ts">
import { useCheckIn, createValidationPlugin } from '#vue-airport/composables/useCheckIn';
import type { ValidationError } from '#vue-airport/plugins/validation';
import FormField from './FormField.vue';
import { type FieldData, FORM_DESK_KEY } from '.';

// Create custom validation plugin
const validationPlugin = createValidationPlugin<FieldData>({
  validate: (data: FieldData) => {
    // Check if required field is filled
    if (data.required && !data.value) {
      return 'This field is required';
    }
    
    // Validate email format
    if (data.type === 'email' && data.value) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(data.value)) {
        return 'Invalid email';
      }
    }
    
    return true;
  },
  maxErrors: 100, // Keep up to 100 validation errors
});

// Create a desk with validation plugin
const { createDesk } = useCheckIn<FieldData>();
const { desk } = createDesk(FORM_DESK_KEY, {
  debug: false,
  plugins: [validationPlugin],
});

// Extend desk type to include validation plugin methods
type DeskWithValidation = typeof desk & {
  getValidationErrors?: () => ValidationError[];
  getLastValidationError?: () => ValidationError | null;
  getValidationErrorsById?: (id: string | number) => ValidationError[];
  clearValidationErrors?: () => void;
  getValidationErrorsByType?: (type: ValidationError['type']) => ValidationError[];
  validationErrorCount?: number;
  hasValidationErrors?: boolean;
  count?: number;
};

const validatedDesk = desk as DeskWithValidation;

// Form fields state
const fieldsData = ref<Array<{
  id: string;
  label: string;
  value: string;
  type: 'text' | 'email' | 'number';
  required: boolean;
}>>([
  {
    id: 'name',
    label: 'Name',
    value: '',
    type: 'text',
    required: true,
  },
  {
    id: 'email',
    label: 'Email',
    value: '',
    type: 'email',
    required: true,
  },
  {
    id: 'age',
    label: 'Age',
    value: '',
    type: 'number',
    required: false,
  },
]);

// Computed properties for validation
const validationErrors = computed(() => validatedDesk.getValidationErrors?.() || []);
const hasErrors = computed(() => validatedDesk.hasValidationErrors ?? false);

// Get current errors by field ID
const errors = computed(() => {
  const errorMap: Record<string, string> = {};
  validationErrors.value.forEach((error: ValidationError) => {
    if (!errorMap[error.id]) {
      errorMap[error.id] = error.message;
    }
  });
  return errorMap;
});

// Track which fields have been touched for better UX
const touchedFields = ref<Set<string>>(new Set());

// Get errors only for touched fields
const errors = computed(() => {
  const errorMap: Record<string, string> = {};
  validationErrors.value.forEach((error: ValidationError) => {
    if (touchedFields.value.has(String(error.id)) && !errorMap[error.id]) {
      errorMap[error.id] = error.message;
    }
  });
  return errorMap;
});

// Check if form is valid (all required fields filled and no validation errors)
const isFormValid = computed(() => {
  const allRequiredFilled = fieldsData.value
    .filter(f => f.required)
    .every(f => f.value.trim() !== '');
  const noValidationErrors = validationErrors.value.length === 0;
  return allRequiredFilled && noValidationErrors;
});

// Function to update field value
const updateFieldValue = (id: string, value: string) => {
  // Mark field as touched
  touchedFields.value.add(id);
  
  const field = fieldsData.value.find(f => f.id === id);
  if (field) {
    field.value = value;
  }
};

// Function to submit the form
const submitForm = () => {
  if (isFormValid.value) {
    const formData = fieldsData.value.reduce((acc, field) => {
      acc[field.id] = field.value;
      return acc;
    }, {} as Record<string, string>);

    alert('Form submitted successfully!\n\n' + JSON.stringify(formData, null, 2));
    
    // Clear validation errors after successful submission
    validatedDesk.clearValidationErrors?.();
  } else {
    const errorList = validationErrors.value.map((e: ValidationError) => `- ${e.message}`).join('\n');
    alert('The form contains errors. Please correct them:\n\n' + errorList);
  }
};

// Function to reset the form
const resetForm = () => {
  fieldsData.value.forEach((field) => {
    field.value = '';
  });
  
  // Clear validation errors when resetting
  validatedDesk.clearValidationErrors?.();
};
</script>

<template>
  <div>
    <form class="form" @submit.prevent="submitForm">
      <FormField
        v-for="field in fieldsData"
        :id="field.id"
        :key="field.id"
        :label="field.label"
        :value="field.value"
        :type="field.type"
        :required="field.required"
        :error="errors[field.id]"
        @update="updateFieldValue"
      />

      <div class="form-actions">
        <UButton
          type="submit"
          icon="i-heroicons-check"
          :disabled="!isFormValid"
        >
          Submit
        </UButton>
        <UButton
          type="button"
          variant="soft"
          icon="i-heroicons-arrow-path"
          @click="resetForm"
        >
          Reset
        </UButton>
      </div>

      <div class="validation-status">
        <UBadge :color="isFormValid ? 'success' : 'error'">
          {{ isFormValid ? '✓ Valid form' : '✗ Invalid form' }}
        </UBadge>
        <span v-if="Object.keys(errors).length > 0" class="error-count">
          {{ Object.keys(errors).length }} error(s)
        </span>
      </div>
    </form>
  </div>
</template>
```

## Child Component (FormField.vue)

Individual form field with automatic validation:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-airport/composables/useCheckIn';
import { type FieldData, FORM_DESK_KEY } from '.';

const props = defineProps<{
  id: string | number;
  label: string;
  value: string;
  type: 'text' | 'email' | 'number';
  required: boolean;
  error?: string;
}>();

const emit = defineEmits<{
  'update:value': [value: string];
}>();

// Local value that syncs with prop
const localValue = ref(props.value);

// Sync local value with prop changes
watch(() => props.value, (newValue) => {
  localValue.value = newValue;
});

// Update local value and emit
const handleInput = (value: string | number) => {
  const stringValue = String(value);
  localValue.value = stringValue;
  emit('update:value', stringValue);
};

// Check in to the desk with watchData on local value
// Validation runs automatically on check-in and on every update
useCheckIn<FieldData>().checkIn(FORM_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  data: () => ({
    label: props.label,
    value: localValue.value,
    type: props.type,
    required: props.required,
  }),
});
</script>

<template>
  <div class="form-field">
    <label :for="String(props.id)" class="label">
      {{ props.label }}
      <span v-if="props.required" class="required">*</span>
    </label>
    <UInput
      :id="String(props.id)"
      :model-value="localValue"
      :type="props.type"
      :placeholder="`Enter ${props.label.toLowerCase()}`"
      @update:model-value="handleInput"
    />
    <span v-if="props.error" class="error">
      {{ props.error }}
    </span>
  </div>
</template>
```

## Key Concepts

### Validation Plugin

The validation plugin provides field-level validation:

```typescript
const validationPlugin = createValidationPlugin<FieldData>({
  validate: (data: FieldData) => {
    // Return error message string, or true if valid
    if (data.required && !data.value) {
      return 'This field is required';
    }
    return true;
  },
  maxErrors: 100,
});
```

### Validation Methods

The plugin extends the desk with validation methods:
- `getValidationErrors()`: Get all validation errors
- `getValidationErrorsById(id)`: Get errors for a specific field
- `clearValidationErrors()`: Clear all errors
- `hasValidationErrors`: Boolean flag indicating if errors exist

### Real-time Validation

Fields are automatically validated when data changes thanks to `watchData` and the `onBeforeUpdate` hook:
1. User types in a field
2. Field's local value updates
3. `watchData` detects the change and calls `desk.update()`
4. Validation plugin's `onBeforeUpdate` hook validates the new data
5. Validation errors are updated or cleared in real-time
6. UI reflects current validation state immediately

### Form Validation State

The form tracks its overall validity:

```typescript
const isFormValid = computed(() => 
  !hasErrors.value && desk.count > 0
);
```

## How It Works

1. **Validation plugin** is created with custom validation logic
2. **Desk is created** with the validation plugin in the parent component
3. **Fields check in** automatically when mounted (`autoCheckIn: true`)
4. **Initial validation** runs via `onBeforeCheckIn` hook (allows check-in even if invalid)
5. **Local value tracking** in each field for independent state management
6. **Data watching** (`watchData: true`) detects value changes
7. **Updates trigger validation** via `onBeforeUpdate` hook on every keystroke
8. **Errors are updated** in real-time and displayed per field
9. **Touched fields** pattern prevents showing errors on pristine fields
10. **Form submission** is enabled only when all validations pass

## Usage

This pattern is ideal for:
- Contact forms with validation
- User registration forms
- Profile editing forms
- Any form requiring field-level validation
- Complex forms with custom validation rules
