# Auto Check-In Example - Enregistrement automatique

Démonstration de l'enregistrement automatique et de la synchronisation réactive.

## Démo interactive

::auto-check-in-example
::

## Vue d'ensemble

Cet exemple met en évidence :
- L'**enregistrement automatique** des composants (`autoCheckIn: true`)
- La **synchronisation automatique** des données (`watchData: true`)
- Le **désenregistrement automatique** lors de la destruction
- La **réactivité complète** entre parent et enfants

## Architecture

### Composant Parent : `AutoCheckInExample.vue`

Le composant parent crée le desk et gère une liste dynamique d'enfants.

```vue
<script setup lang="ts">
import { useCheckIn } from '@/vue-checkin/composables/useCheckIn';
import DemoChild from './DemoChild.vue';
import { AUTO_DESK_KEY } from './index';

interface ChildData {
  name: string;
  status: 'active' | 'inactive' | 'pending';
  count: number;
}

// Créer un desk parent
const { createDesk } = useCheckIn<ChildData>();
const { desk } = createDesk(AUTO_DESK_KEY, {
  debug: true,
});

// État pour gérer les composants enfants
const children = ref([
  { id: 'child-1', name: 'Composant A', status: 'active', count: 0 },
  { id: 'child-2', name: 'Composant B', status: 'inactive', count: 0 },
]);

// Computed pour afficher les items enregistrés
const registeredItems = computed(() => desk.getAll());
</script>
```

### Composant Enfant : `DemoChild.vue`

Chaque enfant s'enregistre automatiquement et synchronise ses props.

```vue
<script setup lang="ts">
import { useCheckIn } from '@/vue-checkin/composables/useCheckIn';
import { AUTO_DESK_KEY } from './index';

interface ChildData {
  name: string;
  status: 'active' | 'inactive' | 'pending';
  count: number;
}

const props = defineProps<{
  id: string;
  name: string;
  status: 'active' | 'inactive' | 'pending';
  count: number;
}>();

// Auto check-in avec watch des données
useCheckIn<ChildData>().checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  data: () => ({
    name: props.name,
    status: props.status,
    count: props.count,
  }),
});
</script>
```

### InjectionKey : `index.ts`

```typescript
import type { InjectionKey } from 'vue';
import type { CheckInDesk } from '@/vue-checkin/composables/useCheckIn';

interface DemoData {
  value: number;
  timestamp: number;
}

export const AUTO_DESK_KEY: InjectionKey<CheckInDesk<DemoData>> = Symbol('autoDesk');

export { default as AutoCheckInExample } from './AutoCheckInExample.vue';
export { default as DemoChild } from './DemoChild.vue';
```

## Fonctionnalités

### Enregistrement automatique

```typescript
useCheckIn<ChildData>().checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,  // ← S'enregistre au montage
  watchData: true,
  data: () => ({ ... }),
});
```

**Comportement :**
- Le composant s'enregistre automatiquement à `onMounted`
- Pas besoin d'appeler manuellement `desk.checkIn()`
- Se désenregistre automatiquement à `onUnmounted`

### Synchronisation réactive

```typescript
useCheckIn<ChildData>().checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,  // ← Synchronise automatiquement
  data: () => ({
    name: props.name,
    status: props.status,
    count: props.count,
  }),
});
```

**Comportement :**
- Les changements de props déclenchent automatiquement `desk.update()`
- Le desk contient toujours les dernières valeurs
- Pas de gestion manuelle de la synchronisation

### Ajouter un enfant

```typescript
const addChild = () => {
  const id = `child-${Date.now()}`;
  children.value.push({
    id,
    name: `Composant ${children.value.length + 1}`,
    status: 'pending',
    count: 0,
  });
};
```

Le nouveau composant s'enregistre automatiquement au desk.

### Modifier un enfant

```typescript
const incrementCount = (id: string) => {
  const child = children.value.find(c => c.id === id);
  if (child) {
    child.count++;
  }
};

const toggleStatus = (id: string) => {
  const child = children.value.find(c => c.id === id);
  if (child) {
    child.status = child.status === 'active' ? 'inactive' : 'active';
  }
};
```

Les modifications sont automatiquement synchronisées avec le desk.

### Retirer un enfant

```typescript
const removeChild = (id: string) => {
  const index = children.value.findIndex(c => c.id === id);
  if (index !== -1) {
    children.value.splice(index, 1);
  }
};
```

Le composant se désenregistre automatiquement du desk.

## Visualisation du registry

```vue
<template>
  <div class="registry-panel">
    <h3>Registry du desk ({{ registeredItems.length }} items)</h3>
    <ul>
      <li v-for="item in registeredItems" :key="item.id">
        <strong>{{ item.id }}</strong>
        <span>{{ item.data.name }}</span>
        <UBadge>{{ item.data.status }}</UBadge>
        <span>Count: {{ item.data.count }}</span>
      </li>
    </ul>
  </div>
</template>
```

## Cycle de vie complet

```
1. Parent crée le desk
   ↓
2. Parent rend les enfants dans le template
   ↓
3. Enfant monte (onMounted)
   ↓
4. autoCheckIn: true → desk.checkIn() appelé automatiquement
   ↓
5. watchData: true → watch sur les props créé
   ↓
6. Props changent
   ↓
7. Watch déclenché → desk.update() appelé automatiquement
   ↓
8. Enfant détruit (onUnmounted)
   ↓
9. desk.checkOut() appelé automatiquement
```

## Concepts clés

::alert{type="success"}
**Auto Check-In** : `autoCheckIn: true` enregistre le composant automatiquement au montage.
::

::alert{type="success"}
**Watch Data** : `watchData: true` synchronise automatiquement les props avec le desk.
::

::alert{type="success"}
**Auto Check-Out** : Le composant se désenregistre automatiquement lors de sa destruction.
::

::alert{type="info"}
**Fonction data** : Doit être une fonction pour être réactive : `data: () => ({ ... })`
::

## Comparaison : Manuel vs Auto

### Enregistrement manuel

```typescript
const { desk } = inject(AUTO_DESK_KEY);

onMounted(() => {
  desk.checkIn(props.id, {
    name: props.name,
    status: props.status,
    count: props.count,
  });
});

watch(() => [props.name, props.status, props.count], () => {
  desk.update(props.id, {
    name: props.name,
    status: props.status,
    count: props.count,
  });
});

onUnmounted(() => {
  desk.checkOut(props.id);
});
```

### Enregistrement automatique

```typescript
useCheckIn<ChildData>().checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  data: () => ({
    name: props.name,
    status: props.status,
    count: props.count,
  }),
});
```

## Utilisation

```vue
<template>
  <AutoCheckInExample />
</template>

<script setup lang="ts">
import { AutoCheckInExample } from '@/components/examples/auto-check-in-example';
</script>
```

## Points d'attention

- `autoCheckIn: true` nécessite que le composant soit dans le contexte d'injection
- `data` doit être une **fonction** pour que la réactivité fonctionne : `data: () => ({ ... })`
- Le watch est créé automatiquement sur toutes les propriétés retournées par `data()`
- Le désenregistrement est automatique, pas besoin de gérer `onUnmounted`
- Parfait pour des listes dynamiques d'enfants (ajout/suppression fréquents)

## Options avancées

### Condition de watch

```typescript
useCheckIn<ChildData>().checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  watchCondition: () => props.status === 'active',  // Ne synchronise que si actif
  data: () => ({ ... }),
});
```

### Watch shallow

```typescript
useCheckIn<ChildData>().checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  shallow: true,  // Watch shallow pour de meilleures performances
  data: () => ({ ... }),
});
```
