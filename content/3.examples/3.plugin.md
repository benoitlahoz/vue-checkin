---
title: Multi-Plugin
description: Active item tracking and operation history monitoring.
navigation:
  icon: i-heroicons-puzzle-piece
seo:
  title: Multi-Plugin - VueAirport
  description: Discover how to use multiple plugins together for active item tracking and operation history monitoring in VueAirport.
---

A comprehensive example demonstrating the use of multiple plugins:

- Active item tracking with `activeItemPlugin`
- Operation history logging with `historyPlugin`
- Real-time history monitoring
- Plugin type extensions
- Reactive state synchronization

::example-loader{:component="MultiPlugin"}
::

## Project Structure

```
multi-plugin/
├── index.ts              # Shared types and injection key
├── MultiPlugin.vue       # Parent component with plugins
└── PluginListItem.vue    # Individual list item component
```

## Shared Types (index.ts)

```typescript
import type { InjectionKey } from 'vue';
import type { DeskCore } from '#vue-airport/composables/useCheckIn';

export interface PluginItemData {
  name: string;
  description: string;
}

export const PLUGIN_DESK_KEY: InjectionKey<DeskCore<PluginItemData>> = Symbol('pluginDesk');

export { default as MultiPlugin } from './MutiPlugin.vue';
export { default as PluginListItem } from './PluginListItem.vue';
```

## Parent Component (MultiPlugin.vue)

Creates a desk with multiple plugins for tracking selections and operations:

```vue
<script setup lang="ts">
import { useCheckIn, createActiveItemPlugin, createHistoryPlugin, type CheckInItem } from '#vue-airport/composables/useCheckIn';
import PluginListItem from './PluginListItem.vue';
import { type PluginItemData, PLUGIN_DESK_KEY } from '.';

// Create plugins for active item tracking and history management
const activeItemPlugin = createActiveItemPlugin<PluginItemData>();
const historyPlugin = createHistoryPlugin<PluginItemData>({ maxHistory: 20 });

// Create a desk with plugins enabled
const { createDesk } = useCheckIn<PluginItemData>();
const { desk } = createDesk(PLUGIN_DESK_KEY, {
  debug: false,
  plugins: [activeItemPlugin, historyPlugin],
});

// Extended type definition to include plugin methods
type DeskWithPlugins = typeof desk & {
  activeId?: Ref<string | number | null>;
  getActive?: () => CheckInItem<PluginItemData> | null;
  getHistory?: () => Array<{ action: string; id: string | number; timestamp: number }>;
  setActive?: (id: string | number | null) => void;
};

const deskWithPlugins = desk as DeskWithPlugins;

// State to manage list items
const itemsData = ref<Array<{
  id: string;
  name: string;
  description: string;
}>>([
  {
    id: 'item-1',
    name: 'First Item',
    description: 'This is the first item in the list',
  },
  {
    id: 'item-2',
    name: 'Second Item',
    description: 'This is the second item',
  },
  {
    id: 'item-3',
    name: 'Third Item',
    description: 'This is the third item',
  },
]);

// Computed properties for active item and history
const activeId = computed(() => deskWithPlugins.activeId?.value);
const activeItem = computed(() => deskWithPlugins.getActive?.());
const history = computed(() => deskWithPlugins.getHistory?.() || []);

// Function to add a new item
const addItem = () => {
  const id = `item-${Date.now()}`;
  itemsData.value.push({
    id,
    name: `Item ${itemsData.value.length + 1}`,
    description: `Description of item ${itemsData.value.length + 1}`,
  });
  
  // Automatically activate the new item
  deskWithPlugins.setActive?.(id);
};

// Function to select an item
const selectItem = (id: string | number) => {
  deskWithPlugins.setActive?.(id);
};

// Function to remove an item
const removeItem = (id: string | number) => {
  // First deactivate if this is the active item
  if (activeId.value === id) {
    deskWithPlugins.setActive?.(null);
  }
  
  const index = itemsData.value.findIndex(item => item.id === id);
  if (index !== -1) {
    itemsData.value.splice(index, 1);
  }
};

// Helper to format action type for display
const formatAction = (action: string) => {
  const actionMap: Record<string, string> = {
    'check-in': 'Registered',
    'check-out': 'Unregistered',
    'update': 'Updated'
  };
  return actionMap[action] || action;
};

// Activate the first item on component mount
onMounted(() => {
  const firstItem = itemsData.value[0];
  if (firstItem) {
    deskWithPlugins.setActive?.(firstItem.id);
  }
});
</script>

<template>
  <div>
    <h2>Plugin Example</h2>
    <p class="description">
      Demonstration of ActiveItem and History plugins for managing selection and tracking operation history.
      Click items to select them, add new items, or remove items to see the history update in real-time.
    </p>

    <div class="controls">
      <UButton icon="i-heroicons-plus" @click="addItem">
        Add Item
      </UButton>
      <UBadge color="primary" variant="subtle">
        {{ itemsData.length }} items
      </UBadge>
      <UBadge color="neutral" variant="subtle">
        {{ history.length }} operations logged
      </UBadge>
    </div>

    <div class="content-grid">
      <!-- Items list -->
      <div class="items-panel">
        <h3>Items ({{ itemsData.length }})</h3>
        <ul class="item-list">
          <PluginListItem
            v-for="item in itemsData"
            :id="item.id"
            :key="item.id"
            :name="item.name"
            :description="item.description"
            :is-active="item.id === activeId"
            @select="selectItem"
            @remove="removeItem"
          />
        </ul>
      </div>

      <!-- Active item details -->
      <div class="details-panel">
        <h3>Active Item</h3>
        <div v-if="activeItem" class="active-details">
          <p><strong>ID:</strong> {{ activeId }}</p>
          <p><strong>Name:</strong> {{ activeItem.data.name }}</p>
          <p><strong>Description:</strong> {{ activeItem.data.description }}</p>
        </div>
        <div v-else class="empty-state">
          No item selected
        </div>
      </div>

      <!-- History panel -->
      <div class="history-panel">
        <h3>Operation History ({{ history.length }} / 20)</h3>
        <p class="history-description">
          Tracks all check-ins, check-outs, and updates. Most recent operations appear first.
        </p>
        <ul class="history-list">
          <li
            v-for="(entry, index) in history.slice().reverse()"
            :key="index"
            class="history-entry"
          >
            <UIcon
              :name="entry.action === 'check-in' ? 'i-heroicons-plus-circle' : entry.action === 'check-out' ? 'i-heroicons-minus-circle' : 'i-heroicons-arrow-path'"
              :class="entry.action === 'check-in' ? 'text-green-500' : entry.action === 'check-out' ? 'text-red-500' : 'text-blue-500'"
            />
            <span class="history-action">{{ formatAction(entry.action) }}</span>
            <span class="history-id">{{ entry.id }}</span>
            <span class="history-time">
              {{ new Date(entry.timestamp).toLocaleTimeString() }}
            </span>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>
```

## Child Component (PluginListItem.vue)

Individual list item with automatic registration:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-airport/composables/useCheckIn';
import { type PluginItemData, PLUGIN_DESK_KEY } from '.';

const props = defineProps<{
  id: string | number;
  name: string;
  description: string;
  isActive: boolean;
}>();

const emit = defineEmits<{
  select: [id: string | number];
  remove: [id: string | number];
}>();

// Automatically check in to the desk with data watching enabled
useCheckIn<PluginItemData>().checkIn(PLUGIN_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  data: () => ({
    name: props.name,
    description: props.description,
  }),
});
</script>

<template>
  <li
    class="item"
    :class="{ active: props.isActive }"
    @click="emit('select', props.id)"
  >
    <div class="item-content">
      <strong>{{ props.name }}</strong>
      <span class="item-id">ID: {{ props.id }}</span>
    </div>
    <UButton
      size="xs"
      color="error"
      variant="ghost"
      icon="i-heroicons-trash"
      @click.stop="emit('remove', props.id)"
    />
  </li>
</template>
```

## Key Concepts

### Multiple Plugins

VueAirport allows combining multiple plugins to extend desk functionality:

```typescript
const activeItemPlugin = createActiveItemPlugin<PluginItemData>();
const historyPlugin = createHistoryPlugin<PluginItemData>({ maxHistory: 20 });

createDesk(PLUGIN_DESK_KEY, {
  plugins: [activeItemPlugin, historyPlugin],
});
```

### Active Item Plugin

Tracks the currently selected item:
- `setActive(id)`: Set the active item
- `getActive()`: Get the active item
- `activeId`: Reactive reference to the active ID

### History Plugin

Maintains a log of all desk operations:
- `getHistory()`: Get the complete operation history
- `getLastHistory(count)`: Get the last N operations
- `getHistoryByAction(action)`: Filter history by action type
- `clearHistory()`: Clear all history entries
- `history`: Reactive reference to the history array

### Type Extensions

Use TypeScript type extensions to access plugin methods:

```typescript
type DeskWithPlugins = typeof desk & {
  activeId?: Ref<string | number | null>;
  getActive?: () => CheckInItem<PluginItemData> | null;
  getHistory?: () => Array<{ action: string; id: string | number; timestamp: number }>;
  setActive?: (id: string | number | null) => void;
};
```

### History Entry Structure

Each history entry contains:
```typescript
{
  action: 'check-in' | 'check-out' | 'update',
  id: string | number,
  data?: T,
  timestamp: number
}
```

## How It Works

1. **Plugins are created** before desk initialization
2. **Desk is created** with plugins array
3. **Plugins extend** the desk with additional methods and reactive properties
4. **Child components** automatically check in when mounted
5. **History records** all check-in, check-out, and update operations with timestamps
6. **Active item** is tracked and updated when selection changes
7. **Real-time monitoring** of all operations through reactive history

## Usage

This pattern is ideal for:
- Lists with selection tracking and operation logging
- Activity monitoring and audit trails
- Debugging component lifecycle issues
- State management with operation history
- Applications needing active item highlighting
- Real-time operation dashboards
