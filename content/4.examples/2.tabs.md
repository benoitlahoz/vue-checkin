---
title: Tabs
description: Dynamic tab management with shared context and active state.
navigation:
  icon: i-heroicons-squares-2x2
seo:
  title: Tabs - VueAirport
  description: Learn how to implement dynamic tabs with shared context, active state management, and automatic component registration using VueAirport.
---

A dynamic tab system demonstrating context sharing and active state management:

- Context sharing between parent and child components
- Dynamic tab creation and deletion
- Automatic component registration with `autoCheckIn`
- Active state synchronization
- Data watching with `watchData`

::example-loader{:component="Tabs"}
::

## Project Structure

```
tabs/
├── index.ts           # Shared types and injection key
├── Tabs.vue           # Parent component managing tabs
└── TabItem.vue        # Individual tab component
```

## Shared Types (index.ts)

```typescript
import type { InjectionKey } from 'vue';
import type { DeskCore } from '#vue-airport/composables/useCheckIn';

export interface TabItemData {
  label: string;
  content: string;
  icon?: string;
}

export const TABS_DESK_KEY: InjectionKey<DeskCore<TabItemData>> = Symbol('tabsDesk');

export { default as Tabs } from './Tabs.vue';
export { default as TabItem } from './TabItem.vue';
```

## Parent Component (Tabs.vue)

Creates the desk with shared context for active tab management:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-airport/composables/useCheckIn';
import { type TabItemData, TABS_DESK_KEY, TabItem } from '.';

// Reactive reference to store the active tab ID
const activeTabId = ref<string | number>('tab-1');

// Create a desk with context to share the active tab state
const { createDesk } = useCheckIn<TabItemData, { activeTab: Ref<string | number> }>();
createDesk(TABS_DESK_KEY, {
  context: { activeTab: activeTabId },
  debug: false,
});

// State to manage all tabs
const tabsData = ref<Array<{
  id: string;
  label: string;
  content: string;
  icon?: string;
}>>([
  {
    id: 'tab-1',
    label: 'Home',
    content: 'Welcome to the tabs demo!',
    icon: 'i-heroicons-home',
  },
  {
    id: 'tab-2',
    label: 'Settings',
    content: 'Application configuration',
    icon: 'i-heroicons-cog-6-tooth',
  },
  {
    id: 'tab-3',
    label: 'Profile',
    content: 'User information',
    icon: 'i-heroicons-user',
  },
]);

// Function to change the active tab
const selectTab = (id: string | number) => {
  activeTabId.value = id;
};

// Function to dynamically add a new tab
const addTab = () => {
  const id = `tab-${Date.now()}`;
  tabsData.value.push({
    id,
    label: `Tab ${tabsData.value.length + 1}`,
    content: `Content of tab ${tabsData.value.length + 1}`,
    icon: 'i-heroicons-document-text',
  });
  selectTab(id);
};

// Function to close a tab
const closeTab = (id: string | number) => {
  // Keep at least one tab open
  if (tabsData.value.length <= 1) return;

  const index = tabsData.value.findIndex(t => t.id === id);
  if (index !== -1) {
    tabsData.value.splice(index, 1);
  }

  // If the active tab is closed, select the first available tab
  if (activeTabId.value === id && tabsData.value.length > 0) {
    const firstTab = tabsData.value[0];
    if (firstTab) {
      activeTabId.value = firstTab.id;
    }
  }
};

// Computed property for the active tab's content
const activeTabContent = computed(() => {
  const tab = tabsData.value.find(t => t.id === activeTabId.value);
  return tab?.content || '';
});
</script>

<template>
  <div>
    <div class="tabs-header">
      <div class="tabs-list">
        <TabItem
          v-for="tab in tabsData"
          :id="tab.id"
          :key="tab.id"
          :label="tab.label"
          :content="tab.content"
          :icon="tab.icon"
          :is-active="tab.id === activeTabId"
          :can-close="tabsData.length > 1"
          @select="selectTab"
          @close="closeTab"
        />
      </div>
      <UButton size="sm" icon="i-heroicons-plus" @click="addTab">
        New Tab
      </UButton>
    </div>

    <div class="tabs-content">
      <p>{{ activeTabContent }}</p>
    </div>
  </div>
</template>
```

## Child Component (TabItem.vue)

Automatically checks in and synchronizes tab data:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-airport/composables/useCheckIn';
import { type TabItemData, TABS_DESK_KEY } from '.';

const props = defineProps<{
  id: string | number;
  label: string;
  content: string;
  icon?: string;
  isActive: boolean;
  canClose: boolean;
}>();

const emit = defineEmits<{
  select: [id: string | number];
  close: [id: string | number];
}>();

// Automatically check in to the desk with data watching enabled
// This keeps the desk registry in sync with the component's props
useCheckIn<TabItemData>().checkIn(TABS_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  data: () => ({
    label: props.label,
    content: props.content,
    icon: props.icon,
  }),
});
</script>

<template>
  <button
    class="tab"
    :class="{ active: props.isActive }"
    @click="emit('select', props.id)"
  >
    <UIcon v-if="props.icon" :name="props.icon" class="tab-icon" />
    <span>{{ props.label }}</span>
    <UButton
      v-if="props.canClose"
      size="xs"
      color="neutral"
      variant="ghost"
      icon="i-heroicons-x-mark"
      @click.stop="emit('close', props.id)"
    />
  </button>
</template>
```

## Key Concepts

### Context Sharing

The desk is created with a **context** object that contains the `activeTab` reference:

```typescript
createDesk(TABS_DESK_KEY, {
  context: { activeTab: activeTabId },
});
```

This allows all child components to access the shared active state.

### Dynamic Tab Management

Tabs can be added and removed dynamically:
- **Add**: Creates a new tab and automatically selects it
- **Remove**: Deletes a tab and selects the first available tab if needed
- **Minimum**: At least one tab must remain open

### Automatic Registration

Child components use `autoCheckIn` to automatically register when mounted and unregister when unmounted, eliminating manual lifecycle management.

## How It Works

1. **Parent creates desk** with shared context containing the active tab ID
2. **Child tabs check in** automatically when mounted with their data
3. **Data synchronization** keeps the desk registry updated when props change
4. **Active state** is shared across all components through context
5. **Dynamic operations** (add/remove tabs) update both the local state and the desk registry

## Usage

This pattern is ideal for:
- Tab interfaces with dynamic content
- Accordion components
- Multi-step forms
- Any UI requiring shared active state
- Components that need to be added/removed dynamically
