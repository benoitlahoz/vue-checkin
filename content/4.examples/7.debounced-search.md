---
title: Debounced Search 
description: Search-as-you-type with debounced event notifications.
navigation:
  icon: i-heroicons-magnifying-glass
seo:
  title: Debounced Search - VueCheckIn
  description: Implement search-as-you-type functionality with VueCheckIn's debounce plugin. Learn event batching, flush/cancel operations, and maxWait configuration.
---

A complete debounced search implementation demonstrating the debounce plugin:

- Debouncing check-in events with configurable delay
- Search-as-you-type functionality
- Event batching with `maxWait` option
- Pending operations tracking
- Manual flush and cancel operations

::example-loader{:component="DebouncedSearch"}
::

## Project Structure

```
debounced-search/
├── index.ts                  # Shared types and injection key
├── DebouncedSearch.vue       # Parent search component
└── SearchResultItem.vue      # Individual result item
```

## Shared Types (index.ts)

```typescript
import type { InjectionKey } from 'vue';
import type { DeskCore } from '#vue-checkin/composables/useCheckIn';

export interface SearchResult {
  title: string;
  description: string;
  category: string;
}

export const SEARCH_DESK_KEY: InjectionKey<DeskCore<SearchResult>> = Symbol('searchDesk');

export { default as DebounceExample } from './DebouncedSearch.vue';
export { default as SearchResultItem } from './SearchResultItem.vue';
```

## Parent Component (DebouncedSearch.vue)

Creates the desk with debounce plugin:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-checkin/composables/useCheckIn';
import { createDebouncePlugin } from '#vue-checkin/plugins';
import SearchResultItem from './SearchResultItem.vue';
import { type SearchResult, SEARCH_DESK_KEY } from '.';

// Create debounce plugin with 500ms delay
const debouncePlugin = createDebouncePlugin<SearchResult>({
  checkInDelay: 500,
  checkOutDelay: 300,
  maxWait: 2000, // Force execution after 2s max
});

// Create a desk with debounce plugin
const { createDesk } = useCheckIn<SearchResult>();
const { desk } = createDesk(SEARCH_DESK_KEY, {
  debug: false,
  plugins: [debouncePlugin],
});

// Extended type to include debounce methods
type DeskWithDebounce = typeof desk & {
  pendingCheckInsCount?: Ref<number>;
  pendingCheckOutsCount?: Ref<number>;
  hasPendingDebounce?: Ref<boolean>;
  flushDebounce?: () => void;
  cancelDebounce?: () => void;
  onDebouncedCheckIn?: (callback: (id: string | number, data: SearchResult) => void) => void;
};

const deskWithDebounce = desk as DeskWithDebounce;

// Search state
const searchQuery = ref('');
const debouncedSearchQuery = ref('');
const searchResults = ref<Array<{
  id: string;
  title: string;
  description: string;
  category: string;
}>>([]);
const isSearching = ref(false);
const lastDebouncedEventTime = ref<string>('Never');
const eventLog = ref<Array<{ time: string; message: string }>>([]);
let searchDebounceTimer: ReturnType<typeof setTimeout> | null = null;

// Mock search database
const mockDatabase = [
  { id: 'vue-1', title: 'Vue 3 Composition API', description: 'Learn about the new Composition API', category: 'Vue' },
  { id: 'vue-2', title: 'Vue Router', description: 'Official routing library', category: 'Vue' },
  { id: 'vue-3', title: 'VueCheckIn Library', description: 'Generic check-in system for Vue', category: 'Vue' },
  { id: 'ts-1', title: 'TypeScript Basics', description: 'Introduction to TypeScript', category: 'TypeScript' },
  { id: 'ts-2', title: 'TypeScript Advanced', description: 'Advanced TypeScript patterns', category: 'TypeScript' },
  { id: 'js-1', title: 'JavaScript ES6+', description: 'Modern JavaScript features', category: 'JavaScript' },
  { id: 'js-2', title: 'Async/Await', description: 'Asynchronous programming', category: 'JavaScript' },
  { id: 'css-1', title: 'CSS Grid Layout', description: 'Master CSS Grid', category: 'CSS' },
  { id: 'css-2', title: 'Flexbox Guide', description: 'Complete flexbox guide', category: 'CSS' },
  { id: 'node-1', title: 'Node.js Fundamentals', description: 'Server-side JavaScript', category: 'Node.js' },
];

// Listen to debounced check-in events
deskWithDebounce.onDebouncedCheckIn?.((id, data) => {
  const time = new Date().toLocaleTimeString();
  lastDebouncedEventTime.value = time;
  addEventLog(`Debounced check-in fired for: ${data.title}`);
});

// Add event to log
const addEventLog = (message: string) => {
  const time = new Date().toLocaleTimeString();
  eventLog.value.unshift({ time, message });
  if (eventLog.value.length > 10) {
    eventLog.value = eventLog.value.slice(0, 10);
  }
};

// Simulate search with debounced results
const performSearch = async (query: string) => {
  if (!query.trim()) {
    searchResults.value = [];
    desk.clear();
    addEventLog('Search cleared');
    return;
  }

  isSearching.value = true;
  addEventLog(`Search executing: "${query}"`);

  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 100));

  const results = mockDatabase.filter(item =>
    item.title.toLowerCase().includes(query.toLowerCase()) ||
    item.description.toLowerCase().includes(query.toLowerCase()) ||
    item.category.toLowerCase().includes(query.toLowerCase())
  );

  searchResults.value = results.map(r => ({ ...r }));
  isSearching.value = false;
  
  addEventLog(`Found ${results.length} results`);
};

// Debounce the search query with 500ms delay
watch(searchQuery, (newQuery) => {
  // Clear existing timer
  if (searchDebounceTimer) {
    clearTimeout(searchDebounceTimer);
  }

  // Show searching state immediately
  if (newQuery.trim()) {
    addEventLog(`Typing: "${newQuery}" (waiting for pause...)`);
  }

  // Set new timer to update debounced value
  searchDebounceTimer = setTimeout(() => {
    debouncedSearchQuery.value = newQuery;
    addEventLog(`Search debounced! Executing search...`);
  }, 500);
});

// Watch debounced query and trigger actual search
watch(debouncedSearchQuery, (newQuery) => {
  performSearch(newQuery);
});

// Computed count of items
const itemCount = computed(() => desk.registryMap.size);

// Pending counts
const pendingCheckIns = computed(() => deskWithDebounce.pendingCheckInsCount?.value ?? 0);
const hasPending = computed(() => deskWithDebounce.hasPendingDebounce?.value ?? false);

// Manually flush debounced events
const flushNow = () => {
  deskWithDebounce.flushDebounce?.();
  addEventLog('Manually flushed debounced events');
};

// Cancel pending debounced events
const cancelPending = () => {
  deskWithDebounce.cancelDebounce?.();
  addEventLog('Cancelled pending debounced events');
};

// Clear search
const clearSearch = () => {
  if (searchDebounceTimer) {
    clearTimeout(searchDebounceTimer);
  }
  searchQuery.value = '';
  debouncedSearchQuery.value = '';
  searchResults.value = [];
  desk.clear();
  eventLog.value = [];
  addEventLog('Search cleared');
};

// Remove a result
const removeResult = (id: string) => {
  const index = searchResults.value.findIndex(r => r.id === id);
  if (index !== -1) {
    searchResults.value.splice(index, 1);
  }
};
</script>

<template>
  <div>
    <!-- Search Controls -->
    <div class="search-section">
      <UInput
        v-model="searchQuery"
        icon="i-heroicons-magnifying-glass"
        size="lg"
        placeholder="Search for Vue, TypeScript, CSS..."
        class="search-input"
      />
      
      <div class="controls">
        <UButton
          icon="i-heroicons-arrow-path"
          color="primary"
          :disabled="!hasPending"
          @click="flushNow"
        >
          Flush Now ({{ pendingCheckIns }})
        </UButton>
        <UButton
          icon="i-heroicons-x-mark"
          color="neutral"
          :disabled="!hasPending"
          @click="cancelPending"
        >
          Cancel Pending
        </UButton>
        <UButton
          icon="i-heroicons-trash"
          color="error"
          @click="clearSearch"
        >
          Clear All
        </UButton>
      </div>
    </div>

    <!-- Stats -->
    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">Results Found</div>
        <div class="stat-value">{{ searchResults.length }}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Checked In</div>
        <div class="stat-value">{{ itemCount }}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Pending Events</div>
        <div class="stat-value" :class="{ 'text-primary': hasPending }">{{ pendingCheckIns }}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Last Debounced Event</div>
        <div class="stat-value small">{{ lastDebouncedEventTime }}</div>
      </div>
    </div>

    <!-- Search Results -->
    <div class="results-section">
      <div v-if="isSearching" class="loading">
        <UIcon name="i-heroicons-arrow-path" class="animate-spin" />
        Searching...
      </div>

      <div v-else-if="searchResults.length === 0 && searchQuery" class="empty-state">
        <UIcon name="i-heroicons-magnifying-glass" />
        <p>No results found for "{{ searchQuery }}"</p>
      </div>

      <div v-else-if="searchResults.length === 0" class="empty-state">
        <UIcon name="i-heroicons-document-magnifying-glass" />
        <p>Type to search...</p>
      </div>

      <TransitionGroup v-else name="list" tag="div" class="results-grid">
        <SearchResultItem
          v-for="result in searchResults"
          :id="result.id"
          :key="result.id"
          :title="result.title"
          :description="result.description"
          :category="result.category"
          @remove="removeResult"
        />
      </TransitionGroup>
    </div>

    <!-- Event Log -->
    <div class="event-log">
      <h3>Event Log</h3>
      <div class="log-entries">
        <TransitionGroup name="log" tag="div">
          <div
            v-for="(entry, index) in eventLog"
            :key="`${entry.time}-${index}`"
            class="log-entry"
          >
            <span class="log-time">{{ entry.time }}</span>
            <span class="log-message">{{ entry.message }}</span>
          </div>
        </TransitionGroup>
        <div v-if="eventLog.length === 0" class="log-empty">
          No events yet
        </div>
      </div>
    </div>
  </div>
</template>
```

## Child Component (SearchResultItem.vue)

Individual search result with automatic check-in:

```vue
<script setup lang="ts">
import { checkInToDesk } from '#vue-checkin/composables/desk-child';
import { type SearchResult, SEARCH_DESK_KEY } from '.';

interface Props extends SearchResult {
  id: string;
}

const props = defineProps<Props>();

const emit = defineEmits<{
  remove: [id: string];
}>();

// Auto check-in to the search desk
const { checkOut, updateSelf } = checkInToDesk(SEARCH_DESK_KEY, {
  id: props.id,
  data: {
    title: props.title,
    description: props.description,
    category: props.category,
  },
});

// Update when props change
watch(() => [props.title, props.description, props.category], () => {
  updateSelf({
    title: props.title,
    description: props.description,
    category: props.category,
  });
});

// Check out on unmount
onUnmounted(() => {
  checkOut();
});

const handleRemove = () => {
  emit('remove', props.id);
};

// Get category color
const getCategoryColor = (category: string) => {
  const colors: Record<string, string> = {
    'Vue': 'primary',
    'TypeScript': 'info',
    'JavaScript': 'warning',
    'CSS': 'secondary',
    'Node.js': 'success',
  };
  return colors[category] || 'neutral';
};
</script>

<template>
  <div class="result-item">
    <div class="result-header">
      <UBadge :color="getCategoryColor(category)" size="xs">
        {{ category }}
      </UBadge>
      <UButton
        icon="i-heroicons-x-mark"
        size="xs"
        color="neutral"
        variant="ghost"
        @click="handleRemove"
      />
    </div>
    
    <h4 class="result-title">{{ title }}</h4>
    <p class="result-description">{{ description }}</p>
  </div>
</template>
```

## Key Concepts

### Debounce Plugin

The debounce plugin delays event notifications:

```typescript
const debouncePlugin = createDebouncePlugin<SearchResult>({
  checkInDelay: 500,      // Delay check-in events by 500ms
  checkOutDelay: 300,     // Delay check-out events by 300ms
  maxWait: 2000,          // Force execution after 2s max
});
```

### Event Batching

Events are batched and delayed:
- **Check-in events** are delayed by `checkInDelay`
- **Check-out events** are delayed by `checkOutDelay`
- **maxWait** ensures events fire even if more keep coming

### Debounce Methods

The plugin extends the desk with control methods:
- `flushDebounce()`: Immediately execute pending events
- `cancelDebounce()`: Cancel all pending events
- `pendingCheckInsCount`: Count of pending check-ins
- `hasPendingDebounce`: Boolean flag for pending events

### onDebouncedCheckIn

Listen to debounced events:

```typescript
deskWithDebounce.onDebouncedCheckIn?.((id, data) => {
  console.log('Debounced event fired!', data);
});
```

## How It Works

1. **User types** in the search field
2. **Search query** is debounced locally with `setTimeout`
3. **Search executes** after 500ms of inactivity
4. **Results check in** to the desk
5. **Debounce plugin** batches check-in events
6. **Events fire** after delay or when `maxWait` is reached
7. **Event log** tracks all debounced operations

## Usage

This pattern is ideal for:
- Search-as-you-type interfaces
- Autocomplete components
- Real-time filters with API calls
- Any scenario requiring event throttling
- Performance optimization for frequent updates
