---
title: Shopping Cart 
description: E-commerce cart with lifecycle hooks and user confirmation.
navigation:
  icon: i-heroicons-shopping-cart
seo:
  title: Shopping Cart - VueAirport
  description: Build a shopping cart with VueAirport featuring lifecycle hooks, onBeforeCheckOut confirmation, and automatic total calculation.
---

A complete e-commerce shopping cart demonstration:

- Lifecycle hooks (`onCheckIn`, `onCheckOut`)
- User confirmation before removing items
- Dynamic cart total calculation
- Product quantity management

::example-loader{:component="ShoppingCart"}
::

## Project Structure

```
shopping-cart/
├── index.ts              # Shared types and injection key
├── ShoppingCart.vue       # Parent cart component
└── ProductCard.vue       # Individual product card
```

## Shared Types (index.ts)

```typescript
import type { InjectionKey } from 'vue';
import type { DeskCore } from '#vue-airport/composables/useCheckIn';

export interface CartItem {
  name: string;
  price: number;
  quantity: number;
  imageUrl?: string;
}

export const CART_DESK_KEY: InjectionKey<DeskCore<CartItem>> = Symbol('cartDesk');

export { default as ShoppingCart } from './ShoppingCart.vue';
export { default as ProductCard } from './ProductCard.vue';
```

## Parent Component (ShoppingCart.vue)

Creates the cart desk with lifecycle hooks:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-airport/composables/useCheckIn';
import ProductCard from './ProductCard.vue';
import { type CartItem, CART_DESK_KEY } from '.';

// Create a desk for the shopping cart with lifecycle hooks
const { createDesk } = useCheckIn<CartItem>();
const { desk } = createDesk(CART_DESK_KEY, {
  debug: false,
  onCheckIn: (_id, data) => {
    console.log(`Product added to cart: ${data.name}`);
  },
  onCheckOut: (id) => {
    console.log(`Product removed from cart: ${id}`);
  },
});

// Available products catalog
const products = ref([
  {
    id: 'product-1',
    name: 'Laptop Pro',
    price: 1299.99,
    quantity: 1,
    imageUrl: 'i-heroicons-computer-desktop',
  },
  {
    id: 'product-2',
    name: 'Wireless Mouse',
    price: 49.99,
    quantity: 1,
    imageUrl: 'i-heroicons-cursor-arrow-rays',
  },
  {
    id: 'product-3',
    name: 'Mechanical Keyboard',
    price: 159.99,
    quantity: 1,
    imageUrl: 'i-heroicons-command-line',
  },
  {
    id: 'product-4',
    name: 'USB-C Hub',
    price: 79.99,
    quantity: 1,
    imageUrl: 'i-heroicons-circle-stack',
  },
  {
    id: 'product-5',
    name: 'Monitor 27"',
    price: 399.99,
    quantity: 1,
    imageUrl: 'i-heroicons-tv',
  },
  {
    id: 'product-6',
    name: 'Webcam HD',
    price: 89.99,
    quantity: 1,
    imageUrl: 'i-heroicons-video-camera',
  },
]);

// Computed properties for cart data
const cartItems = computed(() => desk.getAll());
const cartCount = computed(() => {
  return cartItems.value.reduce((total, item) => {
    return total + item.data.quantity;
  }, 0);
});
const cartTotal = computed(() => {
  return cartItems.value.reduce((total, item) => {
    return total + item.data.price * item.data.quantity;
  }, 0);
});

// Function to update product quantity
const updateQuantity = (id: string, quantity: number) => {
  const product = products.value.find((p) => p.id === id);
  if (product) {
    product.quantity = Math.max(1, quantity);
  }
};

// Function to remove item from cart
const removeFromCart = (id: string | number) => {
  if (window.confirm('Remove this item from cart?')) {
    desk.checkOut(id);
  }
};

// Function to update cart item quantity
const updateCartQuantity = (id: string | number, newQty: number) => {
  desk.update(id, { quantity: newQty });
  updateQuantity(id as string, newQty);
};

// Function to clear the entire cart
const clearCart = () => {
  if (window.confirm('Do you really want to empty the cart?')) {
    desk.clear();
  }
};

// Function to proceed to checkout
const checkout = () => {
  if (cartItems.value.length === 0) {
    window.alert('Your cart is empty!');
    return;
  }

  const orderSummary = cartItems.value
    .map(
      (item) =>
        `${item.data.name} x${item.data.quantity} - $${(item.data.price * item.data.quantity).toFixed(2)}`
    )
    .join('\n');

  window.alert(`Order confirmed!\n\nSummary:\n${orderSummary}\n\nTotal: $${cartTotal.value.toFixed(2)}`);
  desk.clear();
};
</script>

<template>
  <div>
    <div class="grid grid-cols-1 lg:grid-cols-[2fr_1fr] gap-8 mt-6">
      <!-- Products section -->
      <div>
        <div class="grid grid-cols-[repeat(auto-fill,minmax(200px,1fr))] gap-4">
          <ProductCard
            v-for="product in products"
            :id="product.id"
            :key="product.id"
            :name="product.name"
            :price="product.price"
            :quantity="product.quantity"
            :image-url="product.imageUrl"
            @update-quantity="updateQuantity"
          />
        </div>
      </div>

      <!-- Shopping cart -->
      <div class="border border-gray-200 dark:border-gray-700 rounded-lg p-6 bg-white dark:bg-gray-900 h-fit sticky top-4">
        <div class="flex justify-between items-center mb-4">
          <UBadge color="primary" variant="subtle">{{ desk.size }} type(s)</UBadge>
          <UBadge color="primary" variant="subtle">{{ cartCount }} item(s)</UBadge>
        </div>

        <div v-if="cartItems.length === 0" class="text-center py-12 px-4 text-gray-500 dark:text-gray-400">
          <UIcon name="i-heroicons-shopping-cart" class="text-5xl mb-4 opacity-30" />
          <p>Your cart is empty</p>
        </div>

        <div v-else class="flex flex-col gap-4">
          <div class="flex flex-col gap-3 max-h-[400px] overflow-y-auto">
            <div
              v-for="item in cartItems"
              :key="item.id"
              class="flex flex-col gap-3 p-3 border border-gray-200 dark:border-gray-700 rounded-md bg-gray-50 dark:bg-gray-800"
            >
              <div class="flex justify-between items-start">
                <div class="flex items-center gap-3">
                  <UIcon :name="item.data.imageUrl || 'i-heroicons-cube'" class="text-2xl text-primary" />
                  <div class="flex flex-col gap-1">
                    <strong>{{ item.data.name }}</strong>
                    <span class="text-sm text-gray-500 dark:text-gray-400">${{ item.data.price.toFixed(2) }} each</span>
                  </div>
                </div>
                <div class="font-semibold text-primary">
                  ${{ (item.data.price * item.data.quantity).toFixed(2) }}
                </div>
              </div>

              <div class="flex justify-between items-center">
                <div class="flex items-center gap-2">
                  <UButton
                    size="xs"
                    color="primary"
                    variant="soft"
                    icon="i-heroicons-minus"
                    :disabled="item.data.quantity <= 1"
                    @click="updateCartQuantity(item.id, item.data.quantity - 1)"
                  />
                  <span class="min-w-8 text-center font-semibold">{{ item.data.quantity }}</span>
                  <UButton
                    size="xs"
                    color="primary"
                    variant="soft"
                    icon="i-heroicons-plus"
                    @click="updateCartQuantity(item.id, item.data.quantity + 1)"
                  />
                </div>

                <UButton
                  size="xs"
                  color="error"
                  variant="ghost"
                  icon="i-heroicons-trash"
                  @click="removeFromCart(item.id)"
                >
                  Remove
                </UButton>
              </div>
            </div>
          </div>

          <div class="border-t-2 border-gray-200 dark:border-gray-700 pt-4">
            <div class="flex justify-between items-center">
              <span class="text-lg font-semibold">Total</span>
              <span class="text-2xl font-bold text-primary">${{ cartTotal.toFixed(2) }}</span>
            </div>
          </div>

          <div class="flex flex-col gap-2">
            <UButton color="primary" icon="i-heroicons-check" block @click="checkout">
              Checkout
            </UButton>
            <UButton color="error" variant="soft" icon="i-heroicons-trash" block @click="clearCart">
              Clear Cart
            </UButton>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
```

## Child Component (ProductCard.vue)

Individual product that can be added to the cart:

```vue
<script setup lang="ts">
import { inject } from 'vue';
import { type CartItem, CART_DESK_KEY } from '.';
import type { DeskCore } from '#vue-airport/composables/useCheckIn';

const props = defineProps<{
  id: string;
  name: string;
  price: number;
  quantity: number;
  imageUrl?: string;
}>();

const emit = defineEmits<{
  updateQuantity: [id: string, quantity: number];
}>();

// Get access to the cart desk directly via inject
// Products (NOT components) are manually added/removed from the cart
const desk = inject<DeskCore<CartItem>>(CART_DESK_KEY);

// Check if product is in the cart
const isInCart = computed(() => desk?.has(props.id) ?? false);

// Function to add product to cart
const addToCart = () => {
  // If already in cart, just increment quantity
  if (desk?.has(props.id)) {
    const currentItem = desk.get(props.id);
    if (currentItem) {
      desk.update(props.id, {
        quantity: currentItem.data.quantity + 1,
      });
      emit('updateQuantity', props.id, currentItem.data.quantity + 1);
    }
  } else {
    // Add new item to cart
    desk?.checkIn(props.id, {
      name: props.name,
      price: props.price,
      quantity: props.quantity,
      imageUrl: props.imageUrl,
    });
  }
};

// Function to remove product from cart
const removeFromCart = () => {
  if (window.confirm('Do you really want to remove this product from the cart?')) {
    desk?.checkOut(props.id);
  }
};

// Function to increment quantity
const increment = () => {
  const newQuantity = props.quantity + 1;
  emit('updateQuantity', props.id, newQuantity);
  // Update the cart with new quantity if item is in cart
  if (desk?.has(props.id)) {
    desk?.update(props.id, {
      quantity: newQuantity,
    });
  }
};

// Function to decrement quantity
const decrement = () => {
  const newQuantity = Math.max(1, props.quantity - 1);
  emit('updateQuantity', props.id, newQuantity);
  // Update the cart with new quantity if item is in cart
  if (desk?.has(props.id)) {
    desk?.update(props.id, {
      quantity: newQuantity,
    });
  }
};
</script>

<template>
  <div class="border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-white dark:bg-gray-900 flex flex-col gap-3 transition-all duration-200 hover:border-primary hover:shadow-md">
    <div class="flex justify-center items-center h-16 text-5xl text-primary opacity-70">
      <UIcon :name="imageUrl || 'i-heroicons-cube'" />
    </div>

    <div class="flex flex-col gap-2 flex-1">
      <h4 class="text-base font-semibold m-0">{{ name }}</h4>
      <div class="text-xl font-bold text-primary">${{ price.toFixed(2) }}</div>
    </div>

    <div class="flex flex-col gap-2">
      <!-- Add to Cart button when not in cart -->
      <UButton
        v-if="!isInCart"
        size="sm"
        color="primary"
        icon="i-heroicons-shopping-cart"
        block
        @click="addToCart"
      >
        Add to Cart
      </UButton>

      <!-- Quantity controls when in cart -->
      <div v-if="isInCart" class="flex items-center gap-2 justify-center">
        <UButton
          size="xs"
          color="primary"
          variant="soft"
          icon="i-heroicons-minus"
          :disabled="quantity <= 1"
          @click="decrement"
        />
        <span class="min-w-8 text-center font-semibold">{{ quantity }}</span>
        <UButton
          size="xs"
          color="primary"
          variant="soft"
          icon="i-heroicons-plus"
          @click="increment"
        />
      </div>

      <UButton
        v-if="isInCart"
        size="xs"
        color="error"
        variant="ghost"
        icon="i-heroicons-trash"
        @click="removeFromCart"
      >
        Remove
      </UButton>

      <UBadge v-if="isInCart" color="success" variant="subtle">
        <UIcon name="i-heroicons-check" />
        In Cart
      </UBadge>
    </div>
  </div>
</template>
```

## Key Concepts

### Lifecycle Hooks

The desk provides lifecycle hooks for tracking operations:

```typescript
createDesk(CART_DESK_KEY, {
  onCheckIn: (id, data) => {
    console.log(`Product added: ${data.name}`);
  },
  onCheckOut: (id) => {
    console.log(`Product removed: ${id}`);
  },
  onBeforeCheckOut: () => {
    // Return false to cancel the check-out
    return confirm('Remove this product?');
  },
});
```

### Direct Desk Access with Inject

Instead of using `checkIn()` to register the component itself, `ProductCard` uses `inject()` to directly access the parent's desk:

```typescript
const desk = inject<DeskCore<CartItem>>(CART_DESK_KEY);
```

This pattern ensures that:
- Only products (not components) are registered in the cart
- Each product ID appears once in the registry
- Clicking "Add to Cart" increments quantity if already present

### Dynamic Calculations

Both item count and total are computed automatically from registry data:

```typescript
// Total number of items (sum of all quantities)
const cartCount = computed(() => {
  return cartItems.value.reduce((total, item) => {
    return total + item.data.quantity;
  }, 0);
});

// Total price
const cartTotal = computed(() => {
  return cartItems.value.reduce((total, item) => {
    return total + item.data.price * item.data.quantity;
  }, 0);
});
```

The desk also provides a reactive `size` property for the number of unique products:

```typescript
desk.size // ComputedRef<number> - number of unique items
```

### Quantity Management

Quantities can be updated both from the product cards and within the cart itself:

```typescript
// In ProductCard - increment/decrement catalog quantity
const increment = () => {
  const newQuantity = props.quantity + 1;
  emit('updateQuantity', props.id, newQuantity);
  // Update cart if item is already in it
  if (desk?.has(props.id)) {
    desk.update(props.id, { quantity: newQuantity });
  }
};

// In ShoppingCart - update cart item quantity directly
const updateCartQuantity = (id: string | number, newQty: number) => {
  desk.update(id, { quantity: newQty });
  updateQuantity(id as string, newQty);
};
```

### User Confirmations

User confirmations are handled in the component methods using `window.confirm()`:

```typescript
const removeFromCart = (id: string | number) => {
  if (window.confirm('Remove this item from cart?')) {
    desk.checkOut(id);
  }
};
```

This approach prevents confirmation dialogs during navigation/unmounting.

## How It Works

1. **Desk is created** in the parent with lifecycle hooks for logging
2. **ProductCard components** use `inject()` to access the desk directly
3. **Products are added** to cart via `desk.checkIn()` with product data
4. **Smart quantity handling**: Re-adding increments quantity instead of duplicating
5. **Quantity updates** use `desk.update()` method for cart items
6. **Removal confirmations** handled in component methods, not in lifecycle hooks
7. **Cart calculations** update automatically when items change
8. **Tailwind CSS** used for styling with dark mode support

## Usage

This pattern is ideal for:
- E-commerce shopping carts
- Product catalogs with cart functionality
- Any system requiring user confirmation before removal
- Applications with calculated totals or summaries
- Checkout flows with item management
