---
title: Auto Check-in 
description: Automatic component registration with data synchronization.
navigation:
  icon: i-heroicons-bolt
seo:
  title: Auto Check-in - VueCheckIn
  description: Learn how to use autoCheckIn and watchData for automatic component lifecycle management and real-time data synchronization.
---

A demonstration of automatic component registration and data synchronization:

- Automatic component registration with `autoCheckIn`
- Data synchronization with `watchData`
- Dynamic component creation and removal
- Real-time registry updates
- Lifecycle hooks (`onCheckIn`, `onCheckOut`)

::example-loader{:component="AutoCheckIn"}
::

## Project Structure

```
auto-check-in/
├── index.ts              # Shared types and injection key
├── AutoCheckIn.vue       # Parent component with desk
└── AutoCheckItem.vue     # Child component with auto check-in
```

## Shared Types (index.ts)

```typescript
import type { InjectionKey } from 'vue';
import type { DeskCore } from '#vue-checkin/composables/useCheckIn';

export interface DemoData {
  name: string;
  status: 'active' | 'inactive' | 'pending';
  count: number;
}

export const AUTO_DESK_KEY: InjectionKey<DeskCore<DemoData>> = Symbol('autoDesk');

export { default as AutoCheckIn } from './AutoCheckIn.vue';
export { default as AutoCheckItem } from './AutoCheckItem.vue';
```

## Parent Component (AutoCheckIn.vue)

Creates the desk and manages child components:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-checkin/composables/useCheckIn';
import { type DemoData, AUTO_DESK_KEY } from '.';

// Create parent desk for child components
const { createDesk } = useCheckIn<DemoData>();
const { desk } = createDesk(AUTO_DESK_KEY, {
  debug: true,
});

// State to manage child components
const children = ref<Array<{
  id: string;
  name: string;
  status: 'active' | 'inactive' | 'pending';
  count: number;
}>>([
  { id: 'child-1', name: 'Component A', status: 'active', count: 0 },
  { id: 'child-2', name: 'Component B', status: 'inactive', count: 0 },
]);

// Computed property to get all registered items from the desk
const registeredItems = computed(() => desk.getAll());

// Function to add a new child component
const addChild = () => {
  const id = `child-${Date.now()}`;
  children.value.push({
    id,
    name: `Component ${String.fromCharCode(65 + children.value.length)}`,
    status: 'pending',
    count: 0,
  });
};

// Function to remove a child component
const removeChild = (id: string) => {
  const index = children.value.findIndex(c => c.id === id);
  if (index !== -1) {
    children.value.splice(index, 1);
  }
};

// Function to increment the counter
const incrementCount = (id: string) => {
  const child = children.value.find(c => c.id === id);
  if (child) {
    child.count++;
  }
};

// Function to toggle the status
const toggleStatus = (id: string) => {
  const child = children.value.find(c => c.id === id);
  if (child) {
    child.status = child.status === 'active' ? 'inactive' : 'active';
  }
};
</script>

<template>
  <div>
    <div class="controls">
      <UButton icon="i-heroicons-plus" @click="addChild">
        Add Component
      </UButton>
      <UBadge color="primary" variant="subtle">
        {{ registeredItems.length }} registered out of {{ children.length }}
      </UBadge>
    </div>

    <div class="grid">
      <!-- Child components -->
      <div class="children-panel">
        <h3>Child Components</h3>
        <div class="children-list">
          <AutoCheckItem
            v-for="child in children"
            :id="child.id"
            :key="child.id"
            :name="child.name"
            :status="child.status"
            :count="child.count"
            @increment="incrementCount(child.id)"
            @toggle-status="toggleStatus(child.id)"
            @remove="removeChild(child.id)"
          />
        </div>
      </div>

      <!-- Desk registry -->
      <div class="registry-panel">
        <h3>Registry (Desk)</h3>
        <div v-if="registeredItems.length === 0" class="empty-state">
          No component registered
        </div>
        <ul v-else class="registry-list">
          <li v-for="item in registeredItems" :key="item.id" class="registry-item">
            <div class="registry-info">
              <strong>{{ item.data.name }}</strong>
              <div class="registry-details">
                <UBadge
                  :color="item.data.status === 'active' ? 'success' : item.data.status === 'inactive' ? 'neutral' : 'warning'"
                  size="xs"
                >
                  {{ item.data.status }}
                </UBadge>
                <span class="count">Count: {{ item.data.count }}</span>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>
```

## Child Component (AutoCheckItem.vue)

Automatically checks in with data watching:

```vue
<script setup lang="ts">
import { useCheckIn } from '#vue-checkin/composables/useCheckIn';
import { type DemoData, AUTO_DESK_KEY } from '.';

const props = defineProps<{
  id: string;
  name: string;
  status: 'active' | 'inactive' | 'pending';
  count: number;
}>();

const emit = defineEmits<{
  increment: [];
  'toggle-status': [];
  remove: [];
}>();

// Automatically check in to the parent desk with data watching enabled
// This ensures the component is registered when mounted and unregistered when unmounted
const { checkIn } = useCheckIn<DemoData>();
checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,
  watchData: true,
  data: () => ({
    name: props.name,
    status: props.status,
    count: props.count,
  }),
});
</script>

<template>
  <div class="child-component" :class="`status-${props.status}`">
    <div class="child-header">
      <strong>{{ props.name }}</strong>
      <UButton
        size="xs"
        color="error"
        variant="ghost"
        icon="i-heroicons-x-mark"
        @click="emit('remove')"
      />
    </div>
    <div class="child-content">
      <div class="child-status">
        <UBadge
          :color="props.status === 'active' ? 'success' : props.status === 'inactive' ? 'neutral' : 'warning'"
          size="sm"
        >
          {{ props.status }}
        </UBadge>
        <UButton
          size="xs"
          variant="soft"
          @click="emit('toggle-status')"
        >
          Toggle
        </UButton>
      </div>
      <div class="child-counter">
        <span>Count: {{ props.count }}</span>
        <UButton
          size="xs"
          icon="i-heroicons-plus"
          @click="emit('increment')"
        >
          +1
        </UButton>
      </div>
    </div>
  </div>
</template>
```

## Key Concepts

### Auto Check-in

The `autoCheckIn` option automatically manages component lifecycle:

```typescript
checkIn(AUTO_DESK_KEY, {
  id: props.id,
  autoCheckIn: true,  // Automatically check in/out on mount/unmount
  watchData: true,    // Watch data changes
  data: () => ({
    name: props.name,
    status: props.status,
    count: props.count,
  }),
});
```

### Data Watching

With `watchData: true`, the desk automatically updates when props change:
- Component props are watched for changes
- Data in the desk registry is updated automatically
- No manual `update()` calls needed

### Lifecycle Management

Auto check-in eliminates manual lifecycle management:
- **onMounted**: Component automatically checks in
- **onUnmounted**: Component automatically checks out
- **Data changes**: Registry is updated automatically

## How It Works

1. **Parent creates desk** to manage child components
2. **Children mount** and automatically check in with their data
3. **Data watching** keeps the registry synchronized with prop changes
4. **User interactions** update local state, which triggers data watchers
5. **Children unmount** and automatically check out
6. **Registry reflects** the current state of all components

## Usage

This pattern is ideal for:
- Dynamic lists of components
- Components with frequently changing state
- Automatic synchronization between parent and children
- Real-time registries and dashboards
- Any scenario requiring automatic lifecycle management
