---
title: Plugin System
description: Extend VueCheckIn functionality with plugins.
navigation:
  icon: i-lucide-plug
seo:
  title: Plugin System
  description: Learn how to use and create plugins to extend VueCheckIn functionality.
---

VueCheckIn provides a powerful plugin system that allows you to extend the functionality of check-in desks with reusable features.

## Plugin Architecture

Plugins can hook into the desk lifecycle and add custom methods, computed properties, and event listeners. Each plugin implements the `CheckInPlugin` interface and can:

- Add reactive state to the desk
- Intercept check-in/check-out operations
- Add custom methods and computed properties
- Subscribe to desk events
- Provide cleanup logic

::callout{icon="i-lucide-puzzle"}
Plugins enable clean separation of concerns by keeping specialized functionality modular and reusable across different desks.
::

## Built-in Plugins

VueCheckIn includes four production-ready plugins:

### Active Item Plugin

Tracks which item is currently active in the registry. Perfect for tabs, navigation, or any single-selection scenario.

```ts
import { useCheckIn, createActiveItemPlugin } from 'vue-checkin';

const { createDesk } = useCheckIn<TabItem>();
const { desk } = createDesk('tabs', {
  plugins: [createActiveItemPlugin()]
});

// Set active item
desk.setActive('tab-1');

// Get active item
const active = desk.getActive(); // CheckInItem<TabItem> | null

// Check if has active
console.log(desk.hasActive); // boolean

// Clear active
desk.clearActive();

// Listen to changes
desk.on('active-changed', ({ id, data }) => {
  console.log('Active changed:', id);
});
```

**Added Methods:**
- `setActive(id)` - Set the active item by ID
- `getActive()` - Get the currently active item
- `clearActive()` - Clear the active item

**Added Properties:**
- `activeId` - Reactive ref to the active item ID
- `hasActive` - Computed boolean indicating if there's an active item

**Emitted Events:**
- `active-changed` - Fired when active item changes

### Validation Plugin

Validates data before check-in, ensuring data integrity with required fields and custom validation logic. Stores validation errors in a cache for programmatic access.

```ts
import { useCheckIn, createValidationPlugin } from 'vue-checkin';

interface FormField {
  name: string;
  email: string;
  age?: number;
}

const { createDesk } = useCheckIn<FormField>();
const { desk } = createDesk('form', {
  plugins: [
    createValidationPlugin({
      // Required fields
      required: ['name', 'email'],
      
      // Custom validation
      validate: (data) => {
        if (!data.email.includes('@')) {
          return 'Invalid email format';
        }
        if (data.age && data.age < 18) {
          return 'Must be 18 or older';
        }
        return true;
      },
      
      // Maximum number of errors to keep in cache
      maxErrors: 50
    })
  ]
});

// This will fail validation
desk.checkIn('field-1', { name: 'John' }); // ❌ Missing required 'email'

// Access validation errors
const errors = desk.getValidationErrors();
console.log(errors);
// [{
//   id: 'field-1',
//   message: "Field 'email' is required for item field-1",
//   timestamp: 1700000000000,
//   type: 'required-field',
//   field: 'email'
// }]

// Get last error
const lastError = desk.getLastValidationError();

// Get errors for specific item
const fieldErrors = desk.getValidationErrorsById('field-1');

// Check error status
console.log(desk.hasValidationErrors); // true
console.log(desk.validationErrorCount); // 1

// Clear errors
desk.clearValidationErrors();

// This will succeed
desk.checkIn('field-2', { name: 'John', email: 'john@example.com' }); // ✅
```

**Options:**
- `required` - Array of required field names
- `validate` - Custom validation function (return `true`, `false`, or error message string)
- `maxErrors` - Maximum number of errors to keep in cache (default: `50`)

**Added Methods:**
- `getValidationErrors()` - Get all validation errors
- `getLastValidationError()` - Get the most recent validation error
- `getValidationErrorsById(id)` - Get errors for a specific item
- `clearValidationErrors()` - Clear all validation errors from cache
- `getValidationErrorsByType(type)` - Filter errors by type (`'required-field'` or `'custom-validation'`)

**Added Properties:**
- `validationErrorCount` - Number of validation errors in cache
- `hasValidationErrors` - Boolean indicating if there are any errors

**Error Structure:**
```ts
interface ValidationError {
  id: string | number;        // Item ID that failed
  message: string;            // Error message
  timestamp: number;          // When the error occurred
  type: 'required-field' | 'custom-validation';
  field?: string;             // Field name (for required field errors)
}
```

**Behavior:**
- Returns `false` from `onBeforeCheckIn` to prevent invalid check-ins
- Stores validation errors in a reactive cache instead of logging to console
- Automatically limits cache size to `maxErrors` entries
- Errors can be accessed and managed programmatically

### Debounce Plugin

Debounces event notifications from check-in and check-out operations to optimize performance in high-frequency scenarios like real-time search or rapid user interactions.

```ts
import { useCheckIn, createDebouncePlugin } from 'vue-checkin';

interface SearchResult {
  title: string;
  description: string;
}

const { createDesk } = useCheckIn<SearchResult>();
const { desk } = createDesk('search', {
  plugins: [
    createDebouncePlugin({
      checkInDelay: 500,
      checkOutDelay: 300,
      maxWait: 2000
    })
  ]
});

// Subscribe to debounced events
desk.onDebouncedCheckIn((id, data) => {
  console.log('Debounced check-in:', data.title);
});

// Check-ins are immediate, but notifications are debounced
desk.checkIn('result-1', { title: 'Vue', description: 'Framework' });
desk.checkIn('result-2', { title: 'Vue Router', description: 'Routing' });
desk.checkIn('result-3', { title: 'VueCheckIn', description: 'State' });
// Only one debounced notification after 500ms with all three items

// Control debouncing
desk.flushDebounce(); // Immediately process pending events
desk.cancelDebounce(); // Cancel all pending events
console.log(desk.pendingCheckInsCount); // Number of pending check-ins
```

**Options:**
- `checkInDelay` - Debounce delay in milliseconds for check-in notifications (default: `300`)
- `checkOutDelay` - Debounce delay in milliseconds for check-out notifications (default: `300`)
- `maxWait` - Maximum time the notification can be delayed before it's forced to execute (optional)

**Added Methods:**
- `onDebouncedCheckIn(callback)` - Subscribe to debounced check-in notifications
- `onDebouncedCheckOut(callback)` - Subscribe to debounced check-out notifications
- `flushDebounce()` - Immediately process all pending event notifications
- `cancelDebounce()` - Cancel all pending event notifications

**Added Properties:**
- `pendingCheckInsCount` - Number of pending check-in notifications
- `pendingCheckOutsCount` - Number of pending check-out notifications
- `hasPendingDebounce` - Boolean indicating if there are any pending notifications

**Behavior:**
- Operations (check-in/check-out) execute immediately and update the registry
- Only the event notifications (`onCheckIn`/`onCheckOut` hooks) are debounced
- Multiple rapid operations are batched into fewer notifications
- The `maxWait` option ensures notifications aren't delayed indefinitely

### History Plugin

Tracks a complete history of all operations performed on the desk with timestamps.

```ts
import { useCheckIn, createHistoryPlugin } from 'vue-checkin';

const { createDesk } = useCheckIn();
const { desk } = createDesk('items', {
  plugins: [
    createHistoryPlugin({ maxHistory: 100 })
  ]
});

// Perform some operations
desk.checkIn('item-1', { name: 'First' });
desk.checkIn('item-2', { name: 'Second' });
desk.update('item-1', { name: 'Updated' });
desk.checkOut('item-2');

// Get full history
const history = desk.getHistory();
// [
//   { action: 'check-in', id: 'item-1', data: {...}, timestamp: 1234567890 },
//   { action: 'check-in', id: 'item-2', data: {...}, timestamp: 1234567891 },
//   { action: 'update', id: 'item-1', data: {...}, timestamp: 1234567892 },
//   { action: 'check-out', id: 'item-2', timestamp: 1234567893 }
// ]

// Get last N entries
const lastThree = desk.getLastHistory(3);

// Filter by action type
const checkIns = desk.getHistoryByAction('check-in');
const updates = desk.getHistoryByAction('update');

// Clear history
desk.clearHistory();
```

**Options:**
- `maxHistory` - Maximum number of entries to keep (default: `50`)

**Added Methods:**
- `getHistory()` - Get the complete history array
- `clearHistory()` - Clear the history
- `getLastHistory(count)` - Get the last N entries
- `getHistoryByAction(action)` - Filter history by action type

**Added Properties:**
- `history` - Reactive ref containing the history array

**History Entry Structure:**
```ts
interface HistoryEntry<T> {
  action: 'check-in' | 'check-out' | 'update';
  id: string | number;
  data?: T;
  timestamp: number;
}
```

## Using Multiple Plugins

Plugins can be combined to create powerful desk configurations:

```ts
import { 
  useCheckIn, 
  createActiveItemPlugin,
  createHistoryPlugin,
  createLoggerPlugin,
  createValidationPlugin
} from 'vue-checkin';

const { createDesk } = useCheckIn<TabItem>();
const { desk } = createDesk('tabs', {
  plugins: [
    createValidationPlugin({ required: ['label'] }),
    createActiveItemPlugin(),
    createHistoryPlugin({ maxHistory: 50 }),
    createLoggerPlugin({ prefix: '[Tabs]', verbose: true })
  ]
});

// All plugins work together:
// 1. Validation checks data
// 2. Logger logs the operation
// 3. History records it
// 4. Active item can be set
```

::callout{type="warning" icon="i-lucide-alert-triangle"}
Plugin order matters! Plugins are executed in the order they're provided. For example, validation should typically come before logging.
::

## Creating Custom Plugins

You can create your own plugins by implementing the `CheckInPlugin` interface:

```ts
import type { CheckInPlugin, CheckInDesk } from 'vue-checkin';

interface MyData {
  count: number;
}

const createCounterPlugin = (): CheckInPlugin<MyData> => ({
  name: 'counter',
  version: '1.0.0',
  
  // Initialize plugin state
  install: (desk: CheckInDesk<MyData>) => {
    const totalCount = ref(0);
    (desk as any).totalCount = totalCount;
    
    // Return cleanup function
    return () => {
      totalCount.value = 0;
    };
  },
  
  // Hook into check-in
  onCheckIn: (id, data) => {
    console.log(`Adding ${data.count} to total`);
  },
  
  // Add custom methods
  methods: {
    getTotalCount(desk: CheckInDesk<MyData>): number {
      return (desk as any).totalCount?.value || 0;
    },
    
    incrementTotal(desk: CheckInDesk<MyData>, amount: number) {
      const totalCount = (desk as any).totalCount;
      if (totalCount) {
        totalCount.value += amount;
      }
    }
  },
  
  // Add computed properties
  computed: {
    hasItems(desk: CheckInDesk<MyData>): boolean {
      return desk.registry.value.size > 0;
    }
  }
});

// Use the custom plugin
const { createDesk } = useCheckIn<MyData>();
const { desk } = createDesk('counter', {
  plugins: [createCounterPlugin()]
});

// Access plugin features
desk.incrementTotal(10);
console.log(desk.getTotalCount()); // 10
console.log(desk.hasItems); // false (no items checked in yet)
```

## Plugin Interface

The complete plugin interface:

```ts
interface CheckInPlugin<T = any> {
  /** Unique plugin name */
  name: string;
  
  /** Optional version */
  version?: string;
  
  /** Called when plugin is installed (return cleanup function) */
  install?: (desk: CheckInDesk<T>) => void | (() => void);
  
  /** Called before check-in (return false to cancel) */
  onBeforeCheckIn?: (id: string | number, data: T) => void | boolean;
  
  /** Called after successful check-in */
  onCheckIn?: (id: string | number, data: T) => void;
  
  /** Called before check-out (return false to cancel) */
  onBeforeCheckOut?: (id: string | number) => void | boolean;
  
  /** Called after successful check-out */
  onCheckOut?: (id: string | number) => void;
  
  /** Custom methods to add to desk */
  methods?: Record<string, (desk: CheckInDesk<T>, ...args: any[]) => any>;
  
  /** Computed properties to add to desk */
  computed?: Record<string, (desk: CheckInDesk<T>) => any>;
}
```

::callout{type="info" icon="i-lucide-book"}
See the [Plugin Example](/examples/plugin-example) for a complete working implementation using multiple plugins together.
::
