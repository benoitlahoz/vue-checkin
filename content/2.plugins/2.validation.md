---
title: Validation Plugin
description: Validate data before check-in with required fields and custom rules.
navigation:
  icon: i-lucide-shield-check
seo:
  title: Validation Plugin
  description: Learn how to use the Validation Plugin to ensure data integrity in VueAirport.
---

The Validation Plugin validates data before check-in, ensuring data integrity with required fields and custom validation logic. It stores validation errors in a cache for programmatic access, making it perfect for forms, user input, and data quality enforcement.

## Installation

```ts
import { useCheckIn, createValidationPlugin } from 'vue-airport';

interface FormField {
  name: string;
  email: string;
  age?: number;
}

const { createDesk } = useCheckIn<FormField>();
const { desk } = createDesk('form', {
  plugins: [
    createValidationPlugin({
      required: ['name', 'email'],
      validate: (data) => {
        if (!data.email.includes('@')) {
          return 'Invalid email format';
        }
        return true;
      }
    })
  ]
});
```

## Options

### `required: (keyof T)[]`

Array of required field names that must be present in the data.

```ts
createValidationPlugin({
  required: ['name', 'email', 'age']
})
```

### `validate: (data: T) => boolean | string`

Custom validation function. Return:
- `true` for valid data
- `false` for invalid data (generic error message)
- A string with a custom error message

```ts
createValidationPlugin({
  validate: (data) => {
    if (data.age && data.age < 18) {
      return 'Must be 18 or older';
    }
    if (!data.email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
      return 'Invalid email format';
    }
    return true;
  }
})
```

### `maxErrors: number`

Maximum number of errors to keep in cache. Default: `50`.

```ts
createValidationPlugin({
  maxErrors: 100
})
```

## Basic Usage

```ts
interface User {
  name: string;
  email: string;
  age?: number;
}

const { desk } = createDesk('users', {
  plugins: [
    createValidationPlugin<User>({
      required: ['name', 'email'],
      validate: (data) => {
        if (!data.email.includes('@')) {
          return 'Invalid email format';
        }
        if (data.age && data.age < 18) {
          return 'Must be 18 or older';
        }
        return true;
      },
      maxErrors: 50
    })
  ]
});

// ✅ Check-in succeeds but validation error is recorded
desk.checkIn('user-1', { name: 'John' }); // Missing email

// ✅ Check-in succeeds but validation error is recorded
desk.checkIn('user-2', { name: 'Jane', email: 'invalid' }); // Invalid format

// ✅ Check-in succeeds but validation error is recorded
desk.checkIn('user-3', { name: 'Bob', email: 'bob@example.com', age: 16 }); // Age < 18

// ✅ Check-in succeeds with no validation errors
desk.checkIn('user-4', { name: 'Alice', email: 'alice@example.com', age: 25 });

// Access errors
const errors = desk.getValidationErrors();
console.log(errors.length); // 3 errors from user-1, user-2, and user-3

// Items are in the desk despite validation errors
console.log(desk.count); // 4
```

## Error Management

### Get All Errors

```ts
const errors = desk.getValidationErrors();
errors.forEach(error => {
  console.log(`${error.id}: ${error.message}`);
});
```

### Get Last Error

```ts
const lastError = desk.getLastValidationError();
if (lastError) {
  console.log(lastError.message);
}
```

### Get Errors by Item ID

```ts
const userErrors = desk.getValidationErrorsById('user-1');
userErrors.forEach(error => {
  console.log(error.message);
});
```

### Get Errors by Type

```ts
// Get required field errors
const requiredErrors = desk.getValidationErrorsByType('required-field');

// Get custom validation errors
const customErrors = desk.getValidationErrorsByType('custom-validation');
```

### Clear Errors

```ts
// Clear all errors
desk.clearValidationErrors();

console.log(desk.hasValidationErrors); // false
console.log(desk.validationErrorCount); // 0
```

## Error Structure

```ts
interface ValidationError {
  /** ID of the item that failed validation */
  id: string | number;
  
  /** Error message */
  message: string;
  
  /** Timestamp when the error occurred */
  timestamp: number;
  
  /** Type of validation error */
  type: 'required-field' | 'custom-validation';
  
  /** Field name (only for required field errors) */
  field?: string;
}
```

## Component Integration

```vue
<script setup lang="ts">
import { useCheckIn, createValidationPlugin } from 'vue-airport';

interface FormData {
  name: string;
  email: string;
  age?: number;
}

const { desk } = createDesk('form', {
  plugins: [
    createValidationPlugin<FormData>({
      required: ['name', 'email'],
      validate: (data) => {
        if (!data.email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
          return 'Please enter a valid email address';
        }
        if (data.age && data.age < 18) {
          return 'You must be at least 18 years old';
        }
        return true;
      }
    })
  ]
});

const formData = reactive({
  name: '',
  email: '',
  age: undefined
});

const submitForm = () => {
  // Check if there are any validation errors
  if (desk.hasValidationErrors) {
    // Get the error messages
    const errors = desk.getValidationErrors();
    alert(errors.map(e => e.message).join('\n'));
  } else {
    console.log('Form submitted successfully!');
    // Clear the form
    desk.clearValidationErrors();
  }
};

// Watch field changes with real-time validation
watch(() => formData.email, () => {
  // Update triggers validation automatically
  desk.update('form-data', { email: formData.email });
});

// Reactive error display
const errors = computed(() => desk.getValidationErrors());
const hasErrors = computed(() => desk.hasValidationErrors);
</script>

<template>
  <form @submit.prevent="submitForm">
    <div>
      <label>Name</label>
      <input v-model="formData.name" />
    </div>
    
    <div>
      <label>Email</label>
      <input v-model="formData.email" type="email" />
    </div>
    
    <div>
      <label>Age</label>
      <input v-model.number="formData.age" type="number" />
    </div>
    
    <div v-if="hasErrors" class="errors">
      <p v-for="error in errors" :key="error.timestamp">
        {{ error.message }}
      </p>
    </div>
    
    <button type="submit">Submit</button>
  </form>
</template>
```

## API Reference

### Methods

#### `getValidationErrors(): ValidationError[]`

Returns all validation errors in the cache.

#### `getLastValidationError(): ValidationError | null`

Returns the most recent validation error or `null` if there are no errors.

#### `getValidationErrorsById(id: string | number): ValidationError[]`

Returns all validation errors for a specific item ID.

#### `clearValidationErrors(): void`

Clears all validation errors from the cache.

#### `getValidationErrorsByType(type: 'required-field' | 'custom-validation'): ValidationError[]`

Returns validation errors filtered by type.

### Properties

#### `validationErrorCount: number`

The number of validation errors currently in the cache.

#### `hasValidationErrors: boolean`

Boolean indicating whether there are any validation errors.

## Behavior

::note
**Non-blocking validation**: The Validation Plugin allows check-in and updates even when validation fails. Instead of blocking operations, it records validation errors in a cache that can be checked programmatically. This allows items to be registered in the desk while still tracking validation issues.
::

::tip
**Real-time validation**: The plugin uses both `onBeforeCheckIn` and `onBeforeUpdate` hooks to validate data on initial check-in and on every subsequent update. When used with `watchData: true`, validation runs automatically as field values change.
::

::warning
**Cache limits**: The error cache is limited to `maxErrors` entries (default: 50). When the limit is reached, the oldest errors are removed as new ones are added.
::

## Advanced Usage

### Multi-step Form Validation

```ts
interface FormStep {
  step: number;
  data: Record<string, any>;
  isValid?: boolean;
}

const { desk } = createDesk('form-steps', {
  plugins: [
    createValidationPlugin<FormStep>({
      required: ['step', 'data'],
      validate: (formStep) => {
        // Validate based on step
        switch (formStep.step) {
          case 1:
            if (!formStep.data.name || !formStep.data.email) {
              return 'Name and email are required for step 1';
            }
            break;
          case 2:
            if (!formStep.data.address) {
              return 'Address is required for step 2';
            }
            break;
          case 3:
            if (!formStep.data.payment) {
              return 'Payment method is required for step 3';
            }
            break;
        }
        return true;
      }
    })
  ]
});
```

### Async Validation Pattern

While the plugin doesn't support async validation directly, you can implement it using a pattern:

```ts
const validateAsync = async (data: User) => {
  // Check if email exists in database
  const exists = await checkEmailExists(data.email);
  if (exists) {
    return 'Email already registered';
  }
  return true;
};

const submitUser = async (id: string, data: User) => {
  // Run async validation first
  const validationResult = await validateAsync(data);
  
  if (validationResult !== true) {
    // Manually add error to cache
    console.error(validationResult);
    return false;
  }
  
  // Then check in (sync validation will run)
  return desk.checkIn(id, data);
};
```

## Use Cases

- **Form validation**: Validate user input before submission
- **Data quality**: Ensure data meets specific criteria
- **Required fields**: Enforce presence of critical information
- **Custom rules**: Implement business logic validation
- **Multi-step forms**: Validate each step independently

## Examples

See the [Form Example](/examples/form) for a complete working implementation.
